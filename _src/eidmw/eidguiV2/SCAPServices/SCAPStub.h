/* SCAPStub.h
   Generated by gSOAP 2.8.28 from SCAP-Services.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_ns1	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeClientService"
#define SOAP_NAMESPACE_OF_ns2	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeClientService"
#define SOAP_NAMESPACE_OF_ns5	"http://www.w3.org/2000/09/xmldsig#"
#define SOAP_NAMESPACE_OF_ns3	"http://www.cartaodecidadao.pt/ccc/commons/messages/Attribute"
#define SOAP_NAMESPACE_OF_ns4	"http://www.cartaodecidadao.pt/ccc/commons/messages/Types"
#define SOAP_NAMESPACE_OF_ns6	"http://uri.etsi.org/01903/v1.3.2#"
#define SOAP_NAMESPACE_OF_ns7	"http://www.cartaodecidadao.pt/ccc/commons/messages/SVG"
#define SOAP_NAMESPACE_OF_ns8	"http://www.cartaodecidadao.pt/ccc/sccc/services/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_ns9	"http://www.cartaodecidadao.pt/ccc/sccc/messages/AttributeSupplierService"
#define SOAP_NAMESPACE_OF_pdf	"http://www.cartaodecidadao.pt/ccc/sccc/services/PDFSignature"
#define SOAP_WSA_200408

#ifndef SCAPStub_H
#define SCAPStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20828
# error "GSOAP VERSION 20828 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/* SCAP-Services.h:736 */
#ifndef SOAP_TYPE_pdf__SignatureOrientationEnumType
#define SOAP_TYPE_pdf__SignatureOrientationEnumType (134)
/* pdf:SignatureOrientationEnumType */
enum pdf__SignatureOrientationEnumType
{
	pdf__SignatureOrientationEnumType__LANDSCAPE = 0,
	pdf__SignatureOrientationEnumType__PORTRAIT = 1
};
#endif

/* wsa.h:119 */
#ifndef SOAP_TYPE_wsa__RelationshipTypeValues
#define SOAP_TYPE_wsa__RelationshipTypeValues (311)
/* wsa:RelationshipTypeValues */
enum wsa__RelationshipTypeValues
{
	wsa__Reply = 0
};
#endif

/* wsa.h:127 */
#ifndef SOAP_TYPE_wsa__FaultSubcodeValues
#define SOAP_TYPE_wsa__FaultSubcodeValues (312)
/* wsa:FaultSubcodeValues */
enum wsa__FaultSubcodeValues
{
	wsa__InvalidMessageInformationHeader = 0,
	wsa__MessageInformationHeaderRequired = 1,
	wsa__DestinationUnreachable = 2,
	wsa__ActionNotSupported = 3,
	wsa__EndpointUnavailable = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

class xsd__base64Binary;	/* SCAP-Services.h:197 */
class ns2__AttributeRequestType;	/* SCAP-Services.h:225 */
class ns2__SingleAttributeRequestType;	/* SCAP-Services.h:228 */
class ns2__PSAAttributeRequestType;	/* SCAP-Services.h:231 */
class ns2__AttributeSupplierListType;	/* SCAP-Services.h:234 */
class ns2__AttributeResponseType;	/* SCAP-Services.h:237 */
class ns2__SingleAttributeResponseType;	/* SCAP-Services.h:240 */
class ns2__UnsignedAttributeResponseType;	/* SCAP-Services.h:243 */
class ns2__AttributesType;	/* SCAP-Services.h:246 */
class ns2__UnsignedAttributesType;	/* SCAP-Services.h:249 */
class ns2__SignedAttributesType;	/* SCAP-Services.h:252 */
class ns2__UnsignedAttributesBasicType;	/* SCAP-Services.h:255 */
class ns2__ResponseResult;	/* SCAP-Services.h:258 */
class ns5__SignatureType;	/* SCAP-Services.h:261 */
class ns5__SignedInfoType;	/* SCAP-Services.h:264 */
class ns5__CanonicalizationMethodType;	/* SCAP-Services.h:267 */
class ns5__SignatureMethodType;	/* SCAP-Services.h:270 */
class ns5__ReferenceType;	/* SCAP-Services.h:273 */
class ns5__TransformsType;	/* SCAP-Services.h:276 */
class ns5__TransformType;	/* SCAP-Services.h:279 */
class ns5__DigestMethodType;	/* SCAP-Services.h:282 */
class ns5__KeyInfoType;	/* SCAP-Services.h:285 */
class ns5__X509DataType;	/* SCAP-Services.h:288 */
union _ns5__union_ObjectType;	/* SCAP-Services.h:1294 */
class ns5__ObjectType;	/* SCAP-Services.h:291 */
class ns3__AttributeType;	/* SCAP-Services.h:303 */
class ns3__AttributeSupplierType;	/* SCAP-Services.h:306 */
class ns3__PersonalDataType;	/* SCAP-Services.h:309 */
class ns3__ExtraIDListType;	/* SCAP-Services.h:312 */
class ns3__ExtraIDType;	/* SCAP-Services.h:315 */
class ns3__MainAttributeType;	/* SCAP-Services.h:318 */
class ns3__LegalActListType;	/* SCAP-Services.h:321 */
class ns3__SubAttributeListType;	/* SCAP-Services.h:324 */
class ns3__SubAttributeType;	/* SCAP-Services.h:327 */
class ns3__ResponseCodeStatusType;	/* SCAP-Services.h:330 */
class ns6__QualifyingPropertiesType;	/* SCAP-Services.h:333 */
class ns6__SignedPropertiesType;	/* SCAP-Services.h:336 */
class ns6__SignedSignaturePropertiesType;	/* SCAP-Services.h:339 */
class ns6__SigningCertificateType;	/* SCAP-Services.h:342 */
class ns6__CertType;	/* SCAP-Services.h:345 */
class ns6__CertDigestType;	/* SCAP-Services.h:348 */
class ns6__IssuerSerialType;	/* SCAP-Services.h:351 */
class ns6__SignerRoleType;	/* SCAP-Services.h:354 */
class ns6__ClaimedRolesListType;	/* SCAP-Services.h:357 */
class ns6__ClaimedRoleType;	/* SCAP-Services.h:360 */
class ns6__UnsignedPropertiesType;	/* SCAP-Services.h:363 */
class ns6__UnsignedSignaturePropertiesType;	/* SCAP-Services.h:366 */
class ns6__CounterSignatureType;	/* SCAP-Services.h:369 */
class ns6__SignatureTimeStampType;	/* SCAP-Services.h:372 */
class ns6__CompleteCertificateRefsType;	/* SCAP-Services.h:375 */
class ns6__CertRefsType;	/* SCAP-Services.h:378 */
class ns6__CompleteRevocationRefsType;	/* SCAP-Services.h:381 */
class ns6__CRLRefsType;	/* SCAP-Services.h:384 */
class ns6__CRLRefType;	/* SCAP-Services.h:387 */
class ns6__DigestAlgAndValueType;	/* SCAP-Services.h:390 */
class ns6__CRLIdentifierType;	/* SCAP-Services.h:393 */
class ns6__OCSPRefsType;	/* SCAP-Services.h:396 */
class ns6__OCSPRefType;	/* SCAP-Services.h:399 */
class ns6__OCSPIdentifierType;	/* SCAP-Services.h:402 */
class ns6__ResponderIDType;	/* SCAP-Services.h:405 */
class ns6__SigAndRefsTimeStampType;	/* SCAP-Services.h:408 */
class ns6__CertificateValuesType;	/* SCAP-Services.h:411 */
class ns6__RevocationValuesType;	/* SCAP-Services.h:417 */
class ns6__CRLValuesType;	/* SCAP-Services.h:420 */
class ns6__OCSPValuesType;	/* SCAP-Services.h:426 */
class ns6__ArchiveTimeStampType;	/* SCAP-Services.h:432 */
class ns7__SVGListType;	/* SCAP-Services.h:450 */
class ns9__AttributeSupplierResponseType;	/* SCAP-Services.h:453 */
class pdf__SignRequest;	/* SCAP-Services.h:456 */
class pdf__PersonalDataType;	/* SCAP-Services.h:459 */
class pdf__AttributeListType;	/* SCAP-Services.h:462 */
class pdf__AttributeType;	/* SCAP-Services.h:465 */
class pdf__AttributeSupplierType;	/* SCAP-Services.h:468 */
class pdf__MainAttributeType;	/* SCAP-Services.h:471 */
class pdf__LegalActListType;	/* SCAP-Services.h:474 */
class pdf__SubAttributeListType;	/* SCAP-Services.h:477 */
class pdf__SubAttributeType;	/* SCAP-Services.h:480 */
class pdf__SignResponse;	/* SCAP-Services.h:483 */
class pdf__Status;	/* SCAP-Services.h:486 */
class ns5__X509CertificateType;	/* SCAP-Services.h:294 */
class ns5__DigestValueType;	/* SCAP-Services.h:297 */
class ns5__SignatureValueType;	/* SCAP-Services.h:300 */
class ns6__EncapsulatedX509CertificateType;	/* SCAP-Services.h:414 */
class ns6__EncapsulatedCRLValueType;	/* SCAP-Services.h:423 */
class ns6__EncapsulatedOCSPValueType;	/* SCAP-Services.h:429 */
struct wsa__EndpointReferenceType;	/* wsa.h:94 */
struct wsa__ReferencePropertiesType;	/* wsa.h:97 */
struct wsa__ReferenceParametersType;	/* wsa.h:100 */
struct wsa__ServiceNameType;	/* wsa.h:103 */
struct wsa__Relationship;	/* wsa.h:106 */
struct __ns1__Attributes;	/* SCAP-Services.h:3251 */
struct __ns8__AttributeSuppliers;	/* SCAP-Services.h:3332 */
struct __pdf__Sign;	/* SCAP-Services.h:3416 */

/* SCAP-Services.h:197 */
#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (11)
/* base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of XSD type xsd:string */
	char *type;	/* optional element of XSD type xsd:string */
	char *options;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_xsd__base64Binary (11)
	virtual int soap_type(void) const { return 11; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type xsd__base64Binary, default initialized and not managed by a soap context
	virtual xsd__base64Binary *soap_alloc(void) const { return SOAP_NEW(xsd__base64Binary); }
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
	friend SOAP_FMAC1 xsd__base64Binary * SOAP_FMAC2 soap_instantiate_xsd__base64Binary(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:225 */
#ifndef SOAP_TYPE_ns2__AttributeRequestType
#define SOAP_TYPE_ns2__AttributeRequestType (21)
/* ns2:AttributeRequestType complex type: */
class SOAP_CMAC ns2__AttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	ns2__AttributeSupplierListType *AttributeSuppliers;	/* required element of XSD type ns2:AttributeSupplierListType */
	bool *AllEnterprises;	/* optional element of XSD type xsd:boolean */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeRequestType (21)
	virtual int soap_type(void) const { return 21; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__AttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeRequestType); }
	         ns2__AttributeRequestType() { ns2__AttributeRequestType::soap_default(NULL); }
	virtual ~ns2__AttributeRequestType() { }
	friend SOAP_FMAC1 ns2__AttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__AttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:228 */
#ifndef SOAP_TYPE_ns2__SingleAttributeRequestType
#define SOAP_TYPE_ns2__SingleAttributeRequestType (22)
/* ns2:SingleAttributeRequestType complex type: */
class SOAP_CMAC ns2__SingleAttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	ns3__AttributeSupplierType *AttributeSuppliers;	/* required element of XSD type ns3:AttributeSupplierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SingleAttributeRequestType (22)
	virtual int soap_type(void) const { return 22; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SingleAttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__SingleAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeRequestType); }
	         ns2__SingleAttributeRequestType() { ns2__SingleAttributeRequestType::soap_default(NULL); }
	virtual ~ns2__SingleAttributeRequestType() { }
	friend SOAP_FMAC1 ns2__SingleAttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__SingleAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:231 */
#ifndef SOAP_TYPE_ns2__PSAAttributeRequestType
#define SOAP_TYPE_ns2__PSAAttributeRequestType (23)
/* ns2:PSAAttributeRequestType complex type: */
class SOAP_CMAC ns2__PSAAttributeRequestType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns3__PersonalDataType *Citizen;	/* required element of XSD type ns3:PersonalDataType */
	std::string *CompanyId;	/* optional element of XSD type ns4:NIPCType */
	std::string *CompanyName;	/* optional element of XSD type ns4:CompanyNameType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__PSAAttributeRequestType (23)
	virtual int soap_type(void) const { return 23; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__PSAAttributeRequestType, default initialized and not managed by a soap context
	virtual ns2__PSAAttributeRequestType *soap_alloc(void) const { return SOAP_NEW(ns2__PSAAttributeRequestType); }
	         ns2__PSAAttributeRequestType() { ns2__PSAAttributeRequestType::soap_default(NULL); }
	virtual ~ns2__PSAAttributeRequestType() { }
	friend SOAP_FMAC1 ns2__PSAAttributeRequestType * SOAP_FMAC2 soap_instantiate_ns2__PSAAttributeRequestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:234 */
#ifndef SOAP_TYPE_ns2__AttributeSupplierListType
#define SOAP_TYPE_ns2__AttributeSupplierListType (24)
/* ns2:AttributeSupplierListType complex type: */
class SOAP_CMAC ns2__AttributeSupplierListType
{
public:
	std::vector<ns3__AttributeSupplierType *> AttributeSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeSupplierListType (24)
	virtual int soap_type(void) const { return 24; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeSupplierListType, default initialized and not managed by a soap context
	virtual ns2__AttributeSupplierListType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeSupplierListType); }
	         ns2__AttributeSupplierListType() { ns2__AttributeSupplierListType::soap_default(NULL); }
	virtual ~ns2__AttributeSupplierListType() { }
	friend SOAP_FMAC1 ns2__AttributeSupplierListType * SOAP_FMAC2 soap_instantiate_ns2__AttributeSupplierListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:237 */
#ifndef SOAP_TYPE_ns2__AttributeResponseType
#define SOAP_TYPE_ns2__AttributeResponseType (25)
/* ns2:AttributeResponseType complex type: */
class SOAP_CMAC ns2__AttributeResponseType
{
public:
	std::string ProcessId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type ns4:ProcessIDType */
	std::vector<ns2__AttributesType *> AttributeResponseValues;	/* required element of XSD type ns2:AttributesType */
	std::string *ErrorMessage;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributeResponseType (25)
	virtual int soap_type(void) const { return 25; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__AttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributeResponseType); }
	         ns2__AttributeResponseType() { ns2__AttributeResponseType::soap_default(NULL); }
	virtual ~ns2__AttributeResponseType() { }
	friend SOAP_FMAC1 ns2__AttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__AttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:240 */
#ifndef SOAP_TYPE_ns2__SingleAttributeResponseType
#define SOAP_TYPE_ns2__SingleAttributeResponseType (26)
/* ns2:SingleAttributeResponseType complex type: */
class SOAP_CMAC ns2__SingleAttributeResponseType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	ns2__AttributesType *AttributeResponseValues;	/* required element of XSD type ns2:AttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SingleAttributeResponseType (26)
	virtual int soap_type(void) const { return 26; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SingleAttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__SingleAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__SingleAttributeResponseType); }
	         ns2__SingleAttributeResponseType() { ns2__SingleAttributeResponseType::soap_default(NULL); }
	virtual ~ns2__SingleAttributeResponseType() { }
	friend SOAP_FMAC1 ns2__SingleAttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__SingleAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:243 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributeResponseType
#define SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
/* ns2:UnsignedAttributeResponseType complex type: */
class SOAP_CMAC ns2__UnsignedAttributeResponseType
{
public:
	std::string ProcessId;	/* required element of XSD type ns4:ProcessIDType */
	std::string *CompanyId;	/* optional element of XSD type ns4:NIPCType */
	std::string *CompanyName;	/* optional element of XSD type ns4:CompanyNameType */
	ns2__UnsignedAttributesType *AttributeResponseValues;	/* required element of XSD type ns2:UnsignedAttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributeResponseType (27)
	virtual int soap_type(void) const { return 27; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributeResponseType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributeResponseType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributeResponseType); }
	         ns2__UnsignedAttributeResponseType() { ns2__UnsignedAttributeResponseType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributeResponseType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributeResponseType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributeResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:246 */
#ifndef SOAP_TYPE_ns2__AttributesType
#define SOAP_TYPE_ns2__AttributesType (28)
/* ns2:AttributesType complex type: */
class SOAP_CMAC ns2__AttributesType
{
public:
	ns3__AttributeSupplierType *ATTRSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	ns2__ResponseResult *ResponseResult;	/* required element of XSD type ns2:ResponseResult */
	ns2__SignedAttributesType *SignedAttributes;	/* optional element of XSD type ns2:SignedAttributesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__AttributesType (28)
	virtual int soap_type(void) const { return 28; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__AttributesType, default initialized and not managed by a soap context
	virtual ns2__AttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__AttributesType); }
	         ns2__AttributesType() { ns2__AttributesType::soap_default(NULL); }
	virtual ~ns2__AttributesType() { }
	friend SOAP_FMAC1 ns2__AttributesType * SOAP_FMAC2 soap_instantiate_ns2__AttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:249 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesType
#define SOAP_TYPE_ns2__UnsignedAttributesType (29)
/* ns2:UnsignedAttributesType complex type: */
class SOAP_CMAC ns2__UnsignedAttributesType
{
public:
	ns2__ResponseResult *ResponseResult;	/* required element of XSD type ns2:ResponseResult */
	ns2__UnsignedAttributesBasicType *UnsignedAttributes;	/* optional element of XSD type ns2:UnsignedAttributesBasicType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributesType (29)
	virtual int soap_type(void) const { return 29; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributesType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesType); }
	         ns2__UnsignedAttributesType() { ns2__UnsignedAttributesType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributesType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributesType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:252 */
#ifndef SOAP_TYPE_ns2__SignedAttributesType
#define SOAP_TYPE_ns2__SignedAttributesType (30)
/* ns2:SignedAttributesType complex type: */
class SOAP_CMAC ns2__SignedAttributesType
{
public:
	std::vector<ns5__SignatureType *> ns3__SignatureAttribute;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__SignedAttributesType (30)
	virtual int soap_type(void) const { return 30; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__SignedAttributesType, default initialized and not managed by a soap context
	virtual ns2__SignedAttributesType *soap_alloc(void) const { return SOAP_NEW(ns2__SignedAttributesType); }
	         ns2__SignedAttributesType() { ns2__SignedAttributesType::soap_default(NULL); }
	virtual ~ns2__SignedAttributesType() { }
	friend SOAP_FMAC1 ns2__SignedAttributesType * SOAP_FMAC2 soap_instantiate_ns2__SignedAttributesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:255 */
#ifndef SOAP_TYPE_ns2__UnsignedAttributesBasicType
#define SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
/* ns2:UnsignedAttributesBasicType complex type: */
class SOAP_CMAC ns2__UnsignedAttributesBasicType
{
public:
	std::vector<ns3__AttributeType *> ns3__Attribute;	/* required element of XSD type ns3:AttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__UnsignedAttributesBasicType (31)
	virtual int soap_type(void) const { return 31; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__UnsignedAttributesBasicType, default initialized and not managed by a soap context
	virtual ns2__UnsignedAttributesBasicType *soap_alloc(void) const { return SOAP_NEW(ns2__UnsignedAttributesBasicType); }
	         ns2__UnsignedAttributesBasicType() { ns2__UnsignedAttributesBasicType::soap_default(NULL); }
	virtual ~ns2__UnsignedAttributesBasicType() { }
	friend SOAP_FMAC1 ns2__UnsignedAttributesBasicType * SOAP_FMAC2 soap_instantiate_ns2__UnsignedAttributesBasicType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:258 */
#ifndef SOAP_TYPE_ns2__ResponseResult
#define SOAP_TYPE_ns2__ResponseResult (32)
/* ns2:ResponseResult complex type: */
class SOAP_CMAC ns2__ResponseResult
{
public:
	std::string ResultCode;	/* required element of XSD type xsd:string */
	std::string ResultMessage;	/* required element of XSD type xsd:string */
	ns3__PersonalDataType *CitizenIDWithExtraInfo;	/* required element of XSD type ns3:PersonalDataType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns2__ResponseResult (32)
	virtual int soap_type(void) const { return 32; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns2__ResponseResult, default initialized and not managed by a soap context
	virtual ns2__ResponseResult *soap_alloc(void) const { return SOAP_NEW(ns2__ResponseResult); }
	         ns2__ResponseResult() { ns2__ResponseResult::soap_default(NULL); }
	virtual ~ns2__ResponseResult() { }
	friend SOAP_FMAC1 ns2__ResponseResult * SOAP_FMAC2 soap_instantiate_ns2__ResponseResult(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:261 */
#ifndef SOAP_TYPE_ns5__SignatureType
#define SOAP_TYPE_ns5__SignatureType (33)
/* Type ns5__SignatureType is a recursive data type (in)directly referencing itself through its (base) class members */
/* ns5:SignatureType complex type: */
class SOAP_CMAC ns5__SignatureType
{
public:
	ns5__SignedInfoType *ns5__SignedInfo;	/* required element of XSD type ns5:SignedInfoType */
	ns5__SignatureValueType *ns5__SignatureValue;	/* required element of XSD type ns5:SignatureValueType */
	ns5__KeyInfoType *ns5__KeyInfo;	/* required element of XSD type ns5:KeyInfoType */
	std::vector<ns5__ObjectType *> ns5__Object;	/* optional element of XSD type ns5:ObjectType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureType (33)
	virtual int soap_type(void) const { return 33; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureType, default initialized and not managed by a soap context
	virtual ns5__SignatureType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureType); }
	         ns5__SignatureType() { ns5__SignatureType::soap_default(NULL); }
	virtual ~ns5__SignatureType() { }
	friend SOAP_FMAC1 ns5__SignatureType * SOAP_FMAC2 soap_instantiate_ns5__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:264 */
#ifndef SOAP_TYPE_ns5__SignedInfoType
#define SOAP_TYPE_ns5__SignedInfoType (34)
/* ns5:SignedInfoType complex type: */
class SOAP_CMAC ns5__SignedInfoType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	ns5__SignatureMethodType *ns5__SignatureMethod;	/* required element of XSD type ns5:SignatureMethodType */
	std::vector<ns5__ReferenceType *> ns5__Reference;	/* required element of XSD type ns5:ReferenceType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignedInfoType (34)
	virtual int soap_type(void) const { return 34; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignedInfoType, default initialized and not managed by a soap context
	virtual ns5__SignedInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__SignedInfoType); }
	         ns5__SignedInfoType() { ns5__SignedInfoType::soap_default(NULL); }
	virtual ~ns5__SignedInfoType() { }
	friend SOAP_FMAC1 ns5__SignedInfoType * SOAP_FMAC2 soap_instantiate_ns5__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:267 */
#ifndef SOAP_TYPE_ns5__CanonicalizationMethodType
#define SOAP_TYPE_ns5__CanonicalizationMethodType (35)
/* ns5:CanonicalizationMethodType complex type: */
class SOAP_CMAC ns5__CanonicalizationMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__CanonicalizationMethodType (35)
	virtual int soap_type(void) const { return 35; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__CanonicalizationMethodType, default initialized and not managed by a soap context
	virtual ns5__CanonicalizationMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__CanonicalizationMethodType); }
	         ns5__CanonicalizationMethodType() { ns5__CanonicalizationMethodType::soap_default(NULL); }
	virtual ~ns5__CanonicalizationMethodType() { }
	friend SOAP_FMAC1 ns5__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ns5__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:270 */
#ifndef SOAP_TYPE_ns5__SignatureMethodType
#define SOAP_TYPE_ns5__SignatureMethodType (36)
/* ns5:SignatureMethodType complex type: */
class SOAP_CMAC ns5__SignatureMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureMethodType (36)
	virtual int soap_type(void) const { return 36; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureMethodType, default initialized and not managed by a soap context
	virtual ns5__SignatureMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureMethodType); }
	         ns5__SignatureMethodType() { ns5__SignatureMethodType::soap_default(NULL); }
	virtual ~ns5__SignatureMethodType() { }
	friend SOAP_FMAC1 ns5__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ns5__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:273 */
#ifndef SOAP_TYPE_ns5__ReferenceType
#define SOAP_TYPE_ns5__ReferenceType (37)
/* ns5:ReferenceType complex type: */
class SOAP_CMAC ns5__ReferenceType
{
public:
	ns5__TransformsType *ns5__Transforms;	/* required element of XSD type ns5:TransformsType */
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	std::string *Type;	/* optional attribute of XSD type xsd:anyURI */
	std::string *URI;	/* optional attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__ReferenceType (37)
	virtual int soap_type(void) const { return 37; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__ReferenceType, default initialized and not managed by a soap context
	virtual ns5__ReferenceType *soap_alloc(void) const { return SOAP_NEW(ns5__ReferenceType); }
	         ns5__ReferenceType() { ns5__ReferenceType::soap_default(NULL); }
	virtual ~ns5__ReferenceType() { }
	friend SOAP_FMAC1 ns5__ReferenceType * SOAP_FMAC2 soap_instantiate_ns5__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:276 */
#ifndef SOAP_TYPE_ns5__TransformsType
#define SOAP_TYPE_ns5__TransformsType (38)
/* ns5:TransformsType complex type: */
class SOAP_CMAC ns5__TransformsType
{
public:
	std::vector<ns5__TransformType *> ns5__Transform;	/* required element of XSD type ns5:TransformType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__TransformsType (38)
	virtual int soap_type(void) const { return 38; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__TransformsType, default initialized and not managed by a soap context
	virtual ns5__TransformsType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformsType); }
	         ns5__TransformsType() { ns5__TransformsType::soap_default(NULL); }
	virtual ~ns5__TransformsType() { }
	friend SOAP_FMAC1 ns5__TransformsType * SOAP_FMAC2 soap_instantiate_ns5__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:279 */
#ifndef SOAP_TYPE_ns5__TransformType
#define SOAP_TYPE_ns5__TransformType (39)
/* ns5:TransformType complex type: */
class SOAP_CMAC ns5__TransformType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__TransformType (39)
	virtual int soap_type(void) const { return 39; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__TransformType, default initialized and not managed by a soap context
	virtual ns5__TransformType *soap_alloc(void) const { return SOAP_NEW(ns5__TransformType); }
	         ns5__TransformType() { ns5__TransformType::soap_default(NULL); }
	virtual ~ns5__TransformType() { }
	friend SOAP_FMAC1 ns5__TransformType * SOAP_FMAC2 soap_instantiate_ns5__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:282 */
#ifndef SOAP_TYPE_ns5__DigestMethodType
#define SOAP_TYPE_ns5__DigestMethodType (40)
/* ns5:DigestMethodType complex type: */
class SOAP_CMAC ns5__DigestMethodType
{
public:
	std::string Algorithm;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__DigestMethodType (40)
	virtual int soap_type(void) const { return 40; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__DigestMethodType, default initialized and not managed by a soap context
	virtual ns5__DigestMethodType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestMethodType); }
	         ns5__DigestMethodType() { ns5__DigestMethodType::soap_default(NULL); }
	virtual ~ns5__DigestMethodType() { }
	friend SOAP_FMAC1 ns5__DigestMethodType * SOAP_FMAC2 soap_instantiate_ns5__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:285 */
#ifndef SOAP_TYPE_ns5__KeyInfoType
#define SOAP_TYPE_ns5__KeyInfoType (41)
/* ns5:KeyInfoType complex type: */
class SOAP_CMAC ns5__KeyInfoType
{
public:
	ns5__X509DataType *ns5__X509Data;	/* required element of XSD type ns5:X509DataType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__KeyInfoType (41)
	virtual int soap_type(void) const { return 41; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__KeyInfoType, default initialized and not managed by a soap context
	virtual ns5__KeyInfoType *soap_alloc(void) const { return SOAP_NEW(ns5__KeyInfoType); }
	         ns5__KeyInfoType() { ns5__KeyInfoType::soap_default(NULL); }
	virtual ~ns5__KeyInfoType() { }
	friend SOAP_FMAC1 ns5__KeyInfoType * SOAP_FMAC2 soap_instantiate_ns5__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:288 */
#ifndef SOAP_TYPE_ns5__X509DataType
#define SOAP_TYPE_ns5__X509DataType (42)
/* ns5:X509DataType complex type: */
class SOAP_CMAC ns5__X509DataType
{
public:
	std::vector<ns5__X509CertificateType *> ns5__X509Certificate;	/* required element of XSD type ns5:X509CertificateType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__X509DataType (42)
	virtual int soap_type(void) const { return 42; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__X509DataType, default initialized and not managed by a soap context
	virtual ns5__X509DataType *soap_alloc(void) const { return SOAP_NEW(ns5__X509DataType); }
	         ns5__X509DataType() { ns5__X509DataType::soap_default(NULL); }
	virtual ~ns5__X509DataType() { }
	friend SOAP_FMAC1 ns5__X509DataType * SOAP_FMAC2 soap_instantiate_ns5__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:1294 */
#ifndef SOAP_TYPE__ns5__union_ObjectType
#define SOAP_TYPE__ns5__union_ObjectType (174)
/* xsd:choice complex type: */
union _ns5__union_ObjectType
{
#define SOAP_UNION__ns5__union_ObjectType_ns6__QualifyingProperties	(1)
	ns6__QualifyingPropertiesType *ns6__QualifyingProperties;
#define SOAP_UNION__ns5__union_ObjectType_ns7__SVGList	(2)
	ns7__SVGListType *ns7__SVGList;
#define SOAP_UNION__ns5__union_ObjectType_ns3__Attribute	(3)
	ns3__AttributeType *ns3__Attribute;
};
#endif

/* SCAP-Services.h:291 */
#ifndef SOAP_TYPE_ns5__ObjectType
#define SOAP_TYPE_ns5__ObjectType (43)
/* ns5:ObjectType complex type: */
class SOAP_CMAC ns5__ObjectType
{
public:
	int __union_ObjectType;	/* union discriminant (of union defined below) */
	union _ns5__union_ObjectType union_ObjectType;
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__ObjectType (43)
	virtual int soap_type(void) const { return 43; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__ObjectType, default initialized and not managed by a soap context
	virtual ns5__ObjectType *soap_alloc(void) const { return SOAP_NEW(ns5__ObjectType); }
	         ns5__ObjectType() { ns5__ObjectType::soap_default(NULL); }
	virtual ~ns5__ObjectType() { }
	friend SOAP_FMAC1 ns5__ObjectType * SOAP_FMAC2 soap_instantiate_ns5__ObjectType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:303 */
#ifndef SOAP_TYPE_ns3__AttributeType
#define SOAP_TYPE_ns3__AttributeType (47)
/* ns3:AttributeType complex type: */
class SOAP_CMAC ns3__AttributeType
{
public:
	ns3__AttributeSupplierType *AttributeSupplier;	/* required element of XSD type ns3:AttributeSupplierType */
	std::string Date;	/* required element of XSD type ns4:DateType */
	std::string Validity;	/* required element of XSD type ns4:ValidityType */
	ns3__PersonalDataType *PersonalData;	/* required element of XSD type ns3:PersonalDataType */
	ns3__MainAttributeType *MainAttribute;	/* required element of XSD type ns3:MainAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeType (47)
	virtual int soap_type(void) const { return 47; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeType, default initialized and not managed by a soap context
	virtual ns3__AttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeType); }
	         ns3__AttributeType() { ns3__AttributeType::soap_default(NULL); }
	virtual ~ns3__AttributeType() { }
	friend SOAP_FMAC1 ns3__AttributeType * SOAP_FMAC2 soap_instantiate_ns3__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:306 */
#ifndef SOAP_TYPE_ns3__AttributeSupplierType
#define SOAP_TYPE_ns3__AttributeSupplierType (48)
/* ns3:AttributeSupplierType complex type: */
class SOAP_CMAC ns3__AttributeSupplierType
{
public:
	std::string Id;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type ns4:NameType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__AttributeSupplierType (48)
	virtual int soap_type(void) const { return 48; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__AttributeSupplierType, default initialized and not managed by a soap context
	virtual ns3__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(ns3__AttributeSupplierType); }
	         ns3__AttributeSupplierType() { ns3__AttributeSupplierType::soap_default(NULL); }
	virtual ~ns3__AttributeSupplierType() { }
	friend SOAP_FMAC1 ns3__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_ns3__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:309 */
#ifndef SOAP_TYPE_ns3__PersonalDataType
#define SOAP_TYPE_ns3__PersonalDataType (49)
/* ns3:PersonalDataType complex type: */
class SOAP_CMAC ns3__PersonalDataType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string NIC;	/* required element of XSD type ns4:NICType */
	ns3__ExtraIDListType *ExtraIDList;	/* optional element of XSD type ns3:ExtraIDListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__PersonalDataType (49)
	virtual int soap_type(void) const { return 49; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__PersonalDataType, default initialized and not managed by a soap context
	virtual ns3__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(ns3__PersonalDataType); }
	         ns3__PersonalDataType() { ns3__PersonalDataType::soap_default(NULL); }
	virtual ~ns3__PersonalDataType() { }
	friend SOAP_FMAC1 ns3__PersonalDataType * SOAP_FMAC2 soap_instantiate_ns3__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:312 */
#ifndef SOAP_TYPE_ns3__ExtraIDListType
#define SOAP_TYPE_ns3__ExtraIDListType (50)
/* ns3:ExtraIDListType complex type: */
class SOAP_CMAC ns3__ExtraIDListType
{
public:
	std::vector<ns3__ExtraIDType *> ExtraID;	/* required element of XSD type ns3:ExtraIDType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDListType (50)
	virtual int soap_type(void) const { return 50; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDListType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDListType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDListType); }
	         ns3__ExtraIDListType() { ns3__ExtraIDListType::soap_default(NULL); }
	virtual ~ns3__ExtraIDListType() { }
	friend SOAP_FMAC1 ns3__ExtraIDListType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:315 */
#ifndef SOAP_TYPE_ns3__ExtraIDType
#define SOAP_TYPE_ns3__ExtraIDType (51)
/* ns3:ExtraIDType complex type: */
class SOAP_CMAC ns3__ExtraIDType
{
public:
	std::string Name;	/* required element of XSD type ns4:NameType */
	std::string Value;	/* required element of XSD type ns4:ExtraIDValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ExtraIDType (51)
	virtual int soap_type(void) const { return 51; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ExtraIDType, default initialized and not managed by a soap context
	virtual ns3__ExtraIDType *soap_alloc(void) const { return SOAP_NEW(ns3__ExtraIDType); }
	         ns3__ExtraIDType() { ns3__ExtraIDType::soap_default(NULL); }
	virtual ~ns3__ExtraIDType() { }
	friend SOAP_FMAC1 ns3__ExtraIDType * SOAP_FMAC2 soap_instantiate_ns3__ExtraIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:318 */
#ifndef SOAP_TYPE_ns3__MainAttributeType
#define SOAP_TYPE_ns3__MainAttributeType (52)
/* ns3:MainAttributeType complex type: */
class SOAP_CMAC ns3__MainAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	ns3__SubAttributeListType *SubAttributeList;	/* optional element of XSD type ns3:SubAttributeListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__MainAttributeType (52)
	virtual int soap_type(void) const { return 52; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__MainAttributeType, default initialized and not managed by a soap context
	virtual ns3__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__MainAttributeType); }
	         ns3__MainAttributeType() { ns3__MainAttributeType::soap_default(NULL); }
	virtual ~ns3__MainAttributeType() { }
	friend SOAP_FMAC1 ns3__MainAttributeType * SOAP_FMAC2 soap_instantiate_ns3__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:321 */
#ifndef SOAP_TYPE_ns3__LegalActListType
#define SOAP_TYPE_ns3__LegalActListType (53)
/* ns3:LegalActListType complex type: */
class SOAP_CMAC ns3__LegalActListType
{
public:
	std::vector<std::string> LegalAct;	/* required element of XSD type ns4:LegalActType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__LegalActListType (53)
	virtual int soap_type(void) const { return 53; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__LegalActListType, default initialized and not managed by a soap context
	virtual ns3__LegalActListType *soap_alloc(void) const { return SOAP_NEW(ns3__LegalActListType); }
	         ns3__LegalActListType() { ns3__LegalActListType::soap_default(NULL); }
	virtual ~ns3__LegalActListType() { }
	friend SOAP_FMAC1 ns3__LegalActListType * SOAP_FMAC2 soap_instantiate_ns3__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:324 */
#ifndef SOAP_TYPE_ns3__SubAttributeListType
#define SOAP_TYPE_ns3__SubAttributeListType (54)
/* ns3:SubAttributeListType complex type: */
class SOAP_CMAC ns3__SubAttributeListType
{
public:
	std::vector<ns3__SubAttributeType *> SubAttribute;	/* required element of XSD type ns3:SubAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeListType (54)
	virtual int soap_type(void) const { return 54; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeListType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeListType); }
	         ns3__SubAttributeListType() { ns3__SubAttributeListType::soap_default(NULL); }
	virtual ~ns3__SubAttributeListType() { }
	friend SOAP_FMAC1 ns3__SubAttributeListType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:327 */
#ifndef SOAP_TYPE_ns3__SubAttributeType
#define SOAP_TYPE_ns3__SubAttributeType (55)
/* ns3:SubAttributeType complex type: */
class SOAP_CMAC ns3__SubAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type ns4:AttributeIDType */
	std::string *Description;	/* optional element of XSD type ns4:DescriptionType */
	std::string *Value;	/* optional element of XSD type ns4:SubAttributeValueType */
	ns3__LegalActListType *LegalActList;	/* optional element of XSD type ns3:LegalActListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__SubAttributeType (55)
	virtual int soap_type(void) const { return 55; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__SubAttributeType, default initialized and not managed by a soap context
	virtual ns3__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(ns3__SubAttributeType); }
	         ns3__SubAttributeType() { ns3__SubAttributeType::soap_default(NULL); }
	virtual ~ns3__SubAttributeType() { }
	friend SOAP_FMAC1 ns3__SubAttributeType * SOAP_FMAC2 soap_instantiate_ns3__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:330 */
#ifndef SOAP_TYPE_ns3__ResponseCodeStatusType
#define SOAP_TYPE_ns3__ResponseCodeStatusType (56)
/* ns3:ResponseCodeStatusType complex type: */
class SOAP_CMAC ns3__ResponseCodeStatusType
{
public:
	std::string Code;	/* required element of XSD type ns4:ResponseCodeType */
	std::string *Message;	/* optional element of XSD type ns4:ResponseCodeMessage */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns3__ResponseCodeStatusType (56)
	virtual int soap_type(void) const { return 56; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns3__ResponseCodeStatusType, default initialized and not managed by a soap context
	virtual ns3__ResponseCodeStatusType *soap_alloc(void) const { return SOAP_NEW(ns3__ResponseCodeStatusType); }
	         ns3__ResponseCodeStatusType() { ns3__ResponseCodeStatusType::soap_default(NULL); }
	virtual ~ns3__ResponseCodeStatusType() { }
	friend SOAP_FMAC1 ns3__ResponseCodeStatusType * SOAP_FMAC2 soap_instantiate_ns3__ResponseCodeStatusType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:333 */
#ifndef SOAP_TYPE_ns6__QualifyingPropertiesType
#define SOAP_TYPE_ns6__QualifyingPropertiesType (57)
/* ns6:QualifyingPropertiesType complex type: */
class SOAP_CMAC ns6__QualifyingPropertiesType
{
public:
	ns6__SignedPropertiesType *ns6__SignedProperties;	/* required element of XSD type ns6:SignedPropertiesType */
	ns6__UnsignedPropertiesType *ns6__UnsignedProperties;	/* optional element of XSD type ns6:UnsignedPropertiesType */
	std::string Target;	/* required attribute of XSD type xsd:anyURI */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__QualifyingPropertiesType (57)
	virtual int soap_type(void) const { return 57; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__QualifyingPropertiesType, default initialized and not managed by a soap context
	virtual ns6__QualifyingPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__QualifyingPropertiesType); }
	         ns6__QualifyingPropertiesType() { ns6__QualifyingPropertiesType::soap_default(NULL); }
	virtual ~ns6__QualifyingPropertiesType() { }
	friend SOAP_FMAC1 ns6__QualifyingPropertiesType * SOAP_FMAC2 soap_instantiate_ns6__QualifyingPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:336 */
#ifndef SOAP_TYPE_ns6__SignedPropertiesType
#define SOAP_TYPE_ns6__SignedPropertiesType (58)
/* ns6:SignedPropertiesType complex type: */
class SOAP_CMAC ns6__SignedPropertiesType
{
public:
	ns6__SignedSignaturePropertiesType *ns6__SignedSignatureProperties;	/* required element of XSD type ns6:SignedSignaturePropertiesType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SignedPropertiesType (58)
	virtual int soap_type(void) const { return 58; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SignedPropertiesType, default initialized and not managed by a soap context
	virtual ns6__SignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__SignedPropertiesType); }
	         ns6__SignedPropertiesType() { ns6__SignedPropertiesType::soap_default(NULL); }
	virtual ~ns6__SignedPropertiesType() { }
	friend SOAP_FMAC1 ns6__SignedPropertiesType * SOAP_FMAC2 soap_instantiate_ns6__SignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:339 */
#ifndef SOAP_TYPE_ns6__SignedSignaturePropertiesType
#define SOAP_TYPE_ns6__SignedSignaturePropertiesType (59)
/* ns6:SignedSignaturePropertiesType complex type: */
class SOAP_CMAC ns6__SignedSignaturePropertiesType
{
public:
	time_t ns6__SigningTime;	/* required element of XSD type ns6:SigningTimeType */
	ns6__SigningCertificateType *ns6__SigningCertificate;	/* required element of XSD type ns6:SigningCertificateType */
	ns6__SignerRoleType *ns6__SignerRole;	/* optional element of XSD type ns6:SignerRoleType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SignedSignaturePropertiesType (59)
	virtual int soap_type(void) const { return 59; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SignedSignaturePropertiesType, default initialized and not managed by a soap context
	virtual ns6__SignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__SignedSignaturePropertiesType); }
	         ns6__SignedSignaturePropertiesType() { ns6__SignedSignaturePropertiesType::soap_default(NULL); }
	virtual ~ns6__SignedSignaturePropertiesType() { }
	friend SOAP_FMAC1 ns6__SignedSignaturePropertiesType * SOAP_FMAC2 soap_instantiate_ns6__SignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:342 */
#ifndef SOAP_TYPE_ns6__SigningCertificateType
#define SOAP_TYPE_ns6__SigningCertificateType (60)
/* ns6:SigningCertificateType complex type: */
class SOAP_CMAC ns6__SigningCertificateType
{
public:
	ns6__CertType *ns6__Cert;	/* required element of XSD type ns6:CertType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SigningCertificateType (60)
	virtual int soap_type(void) const { return 60; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SigningCertificateType, default initialized and not managed by a soap context
	virtual ns6__SigningCertificateType *soap_alloc(void) const { return SOAP_NEW(ns6__SigningCertificateType); }
	         ns6__SigningCertificateType() { ns6__SigningCertificateType::soap_default(NULL); }
	virtual ~ns6__SigningCertificateType() { }
	friend SOAP_FMAC1 ns6__SigningCertificateType * SOAP_FMAC2 soap_instantiate_ns6__SigningCertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:345 */
#ifndef SOAP_TYPE_ns6__CertType
#define SOAP_TYPE_ns6__CertType (61)
/* ns6:CertType complex type: */
class SOAP_CMAC ns6__CertType
{
public:
	ns6__CertDigestType *ns6__CertDigest;	/* required element of XSD type ns6:CertDigestType */
	ns6__IssuerSerialType *ns6__IssuerSerial;	/* required element of XSD type ns6:IssuerSerialType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CertType (61)
	virtual int soap_type(void) const { return 61; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CertType, default initialized and not managed by a soap context
	virtual ns6__CertType *soap_alloc(void) const { return SOAP_NEW(ns6__CertType); }
	         ns6__CertType() { ns6__CertType::soap_default(NULL); }
	virtual ~ns6__CertType() { }
	friend SOAP_FMAC1 ns6__CertType * SOAP_FMAC2 soap_instantiate_ns6__CertType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:348 */
#ifndef SOAP_TYPE_ns6__CertDigestType
#define SOAP_TYPE_ns6__CertDigestType (62)
/* ns6:CertDigestType complex type: */
class SOAP_CMAC ns6__CertDigestType
{
public:
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CertDigestType (62)
	virtual int soap_type(void) const { return 62; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CertDigestType, default initialized and not managed by a soap context
	virtual ns6__CertDigestType *soap_alloc(void) const { return SOAP_NEW(ns6__CertDigestType); }
	         ns6__CertDigestType() { ns6__CertDigestType::soap_default(NULL); }
	virtual ~ns6__CertDigestType() { }
	friend SOAP_FMAC1 ns6__CertDigestType * SOAP_FMAC2 soap_instantiate_ns6__CertDigestType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:351 */
#ifndef SOAP_TYPE_ns6__IssuerSerialType
#define SOAP_TYPE_ns6__IssuerSerialType (63)
/* ns6:IssuerSerialType complex type: */
class SOAP_CMAC ns6__IssuerSerialType
{
public:
	std::string ns5__X509IssuerName;	/* required element of XSD type ns5:X509IssuerNameType */
	std::string ns5__X509SerialNumber;	/* required element of XSD type ns5:X509SerialNumberType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__IssuerSerialType (63)
	virtual int soap_type(void) const { return 63; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__IssuerSerialType, default initialized and not managed by a soap context
	virtual ns6__IssuerSerialType *soap_alloc(void) const { return SOAP_NEW(ns6__IssuerSerialType); }
	         ns6__IssuerSerialType() { ns6__IssuerSerialType::soap_default(NULL); }
	virtual ~ns6__IssuerSerialType() { }
	friend SOAP_FMAC1 ns6__IssuerSerialType * SOAP_FMAC2 soap_instantiate_ns6__IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:354 */
#ifndef SOAP_TYPE_ns6__SignerRoleType
#define SOAP_TYPE_ns6__SignerRoleType (64)
/* ns6:SignerRoleType complex type: */
class SOAP_CMAC ns6__SignerRoleType
{
public:
	ns6__ClaimedRolesListType *ns6__ClaimedRoles;	/* required element of XSD type ns6:ClaimedRolesListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SignerRoleType (64)
	virtual int soap_type(void) const { return 64; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SignerRoleType, default initialized and not managed by a soap context
	virtual ns6__SignerRoleType *soap_alloc(void) const { return SOAP_NEW(ns6__SignerRoleType); }
	         ns6__SignerRoleType() { ns6__SignerRoleType::soap_default(NULL); }
	virtual ~ns6__SignerRoleType() { }
	friend SOAP_FMAC1 ns6__SignerRoleType * SOAP_FMAC2 soap_instantiate_ns6__SignerRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:357 */
#ifndef SOAP_TYPE_ns6__ClaimedRolesListType
#define SOAP_TYPE_ns6__ClaimedRolesListType (65)
/* ns6:ClaimedRolesListType complex type: */
class SOAP_CMAC ns6__ClaimedRolesListType
{
public:
	std::vector<ns6__ClaimedRoleType *> ns6__ClaimedRole;	/* required element of XSD type ns6:ClaimedRoleType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__ClaimedRolesListType (65)
	virtual int soap_type(void) const { return 65; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__ClaimedRolesListType, default initialized and not managed by a soap context
	virtual ns6__ClaimedRolesListType *soap_alloc(void) const { return SOAP_NEW(ns6__ClaimedRolesListType); }
	         ns6__ClaimedRolesListType() { ns6__ClaimedRolesListType::soap_default(NULL); }
	virtual ~ns6__ClaimedRolesListType() { }
	friend SOAP_FMAC1 ns6__ClaimedRolesListType * SOAP_FMAC2 soap_instantiate_ns6__ClaimedRolesListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:360 */
#ifndef SOAP_TYPE_ns6__ClaimedRoleType
#define SOAP_TYPE_ns6__ClaimedRoleType (66)
/* ns6:ClaimedRoleType complex type: */
class SOAP_CMAC ns6__ClaimedRoleType
{
public:
	ns5__SignatureType *ns3__SignatureAttribute;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__ClaimedRoleType (66)
	virtual int soap_type(void) const { return 66; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__ClaimedRoleType, default initialized and not managed by a soap context
	virtual ns6__ClaimedRoleType *soap_alloc(void) const { return SOAP_NEW(ns6__ClaimedRoleType); }
	         ns6__ClaimedRoleType() { ns6__ClaimedRoleType::soap_default(NULL); }
	virtual ~ns6__ClaimedRoleType() { }
	friend SOAP_FMAC1 ns6__ClaimedRoleType * SOAP_FMAC2 soap_instantiate_ns6__ClaimedRoleType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:363 */
#ifndef SOAP_TYPE_ns6__UnsignedPropertiesType
#define SOAP_TYPE_ns6__UnsignedPropertiesType (67)
/* ns6:UnsignedPropertiesType complex type: */
class SOAP_CMAC ns6__UnsignedPropertiesType
{
public:
	ns6__UnsignedSignaturePropertiesType *ns6__UnsignedSignatureProperties;	/* required element of XSD type ns6:UnsignedSignaturePropertiesType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__UnsignedPropertiesType (67)
	virtual int soap_type(void) const { return 67; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__UnsignedPropertiesType, default initialized and not managed by a soap context
	virtual ns6__UnsignedPropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__UnsignedPropertiesType); }
	         ns6__UnsignedPropertiesType() { ns6__UnsignedPropertiesType::soap_default(NULL); }
	virtual ~ns6__UnsignedPropertiesType() { }
	friend SOAP_FMAC1 ns6__UnsignedPropertiesType * SOAP_FMAC2 soap_instantiate_ns6__UnsignedPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:366 */
#ifndef SOAP_TYPE_ns6__UnsignedSignaturePropertiesType
#define SOAP_TYPE_ns6__UnsignedSignaturePropertiesType (68)
/* ns6:UnsignedSignaturePropertiesType complex type: */
class SOAP_CMAC ns6__UnsignedSignaturePropertiesType
{
public:
	ns6__CounterSignatureType *ns6__CounterSignature;	/* optional element of XSD type ns6:CounterSignatureType */
	ns6__SignatureTimeStampType *ns6__SignatureTimeStamp;	/* required element of XSD type ns6:SignatureTimeStampType */
	ns6__CompleteCertificateRefsType *ns6__CompleteCertificateRefs;	/* required element of XSD type ns6:CompleteCertificateRefsType */
	ns6__CompleteRevocationRefsType *ns6__CompleteRevocationRefs;	/* required element of XSD type ns6:CompleteRevocationRefsType */
	ns6__SigAndRefsTimeStampType *ns6__SigAndRefsTimeStamp;	/* required element of XSD type ns6:SigAndRefsTimeStampType */
	ns6__CertificateValuesType *ns6__CertificateValues;	/* required element of XSD type ns6:CertificateValuesType */
	ns6__RevocationValuesType *ns6__RevocationValues;	/* required element of XSD type ns6:RevocationValuesType */
	ns6__ArchiveTimeStampType *ns6__ArchiveTimeStamp;	/* required element of XSD type ns6:ArchiveTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__UnsignedSignaturePropertiesType (68)
	virtual int soap_type(void) const { return 68; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__UnsignedSignaturePropertiesType, default initialized and not managed by a soap context
	virtual ns6__UnsignedSignaturePropertiesType *soap_alloc(void) const { return SOAP_NEW(ns6__UnsignedSignaturePropertiesType); }
	         ns6__UnsignedSignaturePropertiesType() { ns6__UnsignedSignaturePropertiesType::soap_default(NULL); }
	virtual ~ns6__UnsignedSignaturePropertiesType() { }
	friend SOAP_FMAC1 ns6__UnsignedSignaturePropertiesType * SOAP_FMAC2 soap_instantiate_ns6__UnsignedSignaturePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:369 */
#ifndef SOAP_TYPE_ns6__CounterSignatureType
#define SOAP_TYPE_ns6__CounterSignatureType (69)
/* ns6:CounterSignatureType complex type: */
class SOAP_CMAC ns6__CounterSignatureType
{
public:
	ns5__SignatureType *ns5__Signature;	/* required element of XSD type ns5:SignatureType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CounterSignatureType (69)
	virtual int soap_type(void) const { return 69; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CounterSignatureType, default initialized and not managed by a soap context
	virtual ns6__CounterSignatureType *soap_alloc(void) const { return SOAP_NEW(ns6__CounterSignatureType); }
	         ns6__CounterSignatureType() { ns6__CounterSignatureType::soap_default(NULL); }
	virtual ~ns6__CounterSignatureType() { }
	friend SOAP_FMAC1 ns6__CounterSignatureType * SOAP_FMAC2 soap_instantiate_ns6__CounterSignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:372 */
#ifndef SOAP_TYPE_ns6__SignatureTimeStampType
#define SOAP_TYPE_ns6__SignatureTimeStampType (70)
/* ns6:SignatureTimeStampType complex type: */
class SOAP_CMAC ns6__SignatureTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns6__EncapsulatedTimeStamp;	/* required element of XSD type ns6:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SignatureTimeStampType (70)
	virtual int soap_type(void) const { return 70; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SignatureTimeStampType, default initialized and not managed by a soap context
	virtual ns6__SignatureTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__SignatureTimeStampType); }
	         ns6__SignatureTimeStampType() { ns6__SignatureTimeStampType::soap_default(NULL); }
	virtual ~ns6__SignatureTimeStampType() { }
	friend SOAP_FMAC1 ns6__SignatureTimeStampType * SOAP_FMAC2 soap_instantiate_ns6__SignatureTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:375 */
#ifndef SOAP_TYPE_ns6__CompleteCertificateRefsType
#define SOAP_TYPE_ns6__CompleteCertificateRefsType (71)
/* ns6:CompleteCertificateRefsType complex type: */
class SOAP_CMAC ns6__CompleteCertificateRefsType
{
public:
	ns6__CertRefsType *ns6__CertRefs;	/* required element of XSD type ns6:CertRefsType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CompleteCertificateRefsType (71)
	virtual int soap_type(void) const { return 71; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CompleteCertificateRefsType, default initialized and not managed by a soap context
	virtual ns6__CompleteCertificateRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CompleteCertificateRefsType); }
	         ns6__CompleteCertificateRefsType() { ns6__CompleteCertificateRefsType::soap_default(NULL); }
	virtual ~ns6__CompleteCertificateRefsType() { }
	friend SOAP_FMAC1 ns6__CompleteCertificateRefsType * SOAP_FMAC2 soap_instantiate_ns6__CompleteCertificateRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:378 */
#ifndef SOAP_TYPE_ns6__CertRefsType
#define SOAP_TYPE_ns6__CertRefsType (72)
/* ns6:CertRefsType complex type: */
class SOAP_CMAC ns6__CertRefsType
{
public:
	std::vector<ns6__CertType *> ns6__Cert;	/* required element of XSD type ns6:CertType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CertRefsType (72)
	virtual int soap_type(void) const { return 72; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CertRefsType, default initialized and not managed by a soap context
	virtual ns6__CertRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CertRefsType); }
	         ns6__CertRefsType() { ns6__CertRefsType::soap_default(NULL); }
	virtual ~ns6__CertRefsType() { }
	friend SOAP_FMAC1 ns6__CertRefsType * SOAP_FMAC2 soap_instantiate_ns6__CertRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:381 */
#ifndef SOAP_TYPE_ns6__CompleteRevocationRefsType
#define SOAP_TYPE_ns6__CompleteRevocationRefsType (73)
/* ns6:CompleteRevocationRefsType complex type: */
class SOAP_CMAC ns6__CompleteRevocationRefsType
{
public:
	ns6__CRLRefsType *ns6__CRLRefs;	/* required element of XSD type ns6:CRLRefsType */
	ns6__OCSPRefsType *ns6__OCSPRefs;	/* required element of XSD type ns6:OCSPRefsType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CompleteRevocationRefsType (73)
	virtual int soap_type(void) const { return 73; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CompleteRevocationRefsType, default initialized and not managed by a soap context
	virtual ns6__CompleteRevocationRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CompleteRevocationRefsType); }
	         ns6__CompleteRevocationRefsType() { ns6__CompleteRevocationRefsType::soap_default(NULL); }
	virtual ~ns6__CompleteRevocationRefsType() { }
	friend SOAP_FMAC1 ns6__CompleteRevocationRefsType * SOAP_FMAC2 soap_instantiate_ns6__CompleteRevocationRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:384 */
#ifndef SOAP_TYPE_ns6__CRLRefsType
#define SOAP_TYPE_ns6__CRLRefsType (74)
/* ns6:CRLRefsType complex type: */
class SOAP_CMAC ns6__CRLRefsType
{
public:
	std::vector<ns6__CRLRefType *> ns6__CRLRef;	/* required element of XSD type ns6:CRLRefType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CRLRefsType (74)
	virtual int soap_type(void) const { return 74; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CRLRefsType, default initialized and not managed by a soap context
	virtual ns6__CRLRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLRefsType); }
	         ns6__CRLRefsType() { ns6__CRLRefsType::soap_default(NULL); }
	virtual ~ns6__CRLRefsType() { }
	friend SOAP_FMAC1 ns6__CRLRefsType * SOAP_FMAC2 soap_instantiate_ns6__CRLRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:387 */
#ifndef SOAP_TYPE_ns6__CRLRefType
#define SOAP_TYPE_ns6__CRLRefType (75)
/* ns6:CRLRefType complex type: */
class SOAP_CMAC ns6__CRLRefType
{
public:
	ns6__DigestAlgAndValueType *ns6__DigestAlgAndValue;	/* required element of XSD type ns6:DigestAlgAndValueType */
	ns6__CRLIdentifierType *ns6__CRLIdentifier;	/* required element of XSD type ns6:CRLIdentifierType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CRLRefType (75)
	virtual int soap_type(void) const { return 75; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CRLRefType, default initialized and not managed by a soap context
	virtual ns6__CRLRefType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLRefType); }
	         ns6__CRLRefType() { ns6__CRLRefType::soap_default(NULL); }
	virtual ~ns6__CRLRefType() { }
	friend SOAP_FMAC1 ns6__CRLRefType * SOAP_FMAC2 soap_instantiate_ns6__CRLRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:390 */
#ifndef SOAP_TYPE_ns6__DigestAlgAndValueType
#define SOAP_TYPE_ns6__DigestAlgAndValueType (76)
/* ns6:DigestAlgAndValueType complex type: */
class SOAP_CMAC ns6__DigestAlgAndValueType
{
public:
	ns5__DigestMethodType *ns5__DigestMethod;	/* required element of XSD type ns5:DigestMethodType */
	ns5__DigestValueType *ns5__DigestValue;	/* required element of XSD type ns5:DigestValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__DigestAlgAndValueType (76)
	virtual int soap_type(void) const { return 76; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__DigestAlgAndValueType, default initialized and not managed by a soap context
	virtual ns6__DigestAlgAndValueType *soap_alloc(void) const { return SOAP_NEW(ns6__DigestAlgAndValueType); }
	         ns6__DigestAlgAndValueType() { ns6__DigestAlgAndValueType::soap_default(NULL); }
	virtual ~ns6__DigestAlgAndValueType() { }
	friend SOAP_FMAC1 ns6__DigestAlgAndValueType * SOAP_FMAC2 soap_instantiate_ns6__DigestAlgAndValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:393 */
#ifndef SOAP_TYPE_ns6__CRLIdentifierType
#define SOAP_TYPE_ns6__CRLIdentifierType (77)
/* ns6:CRLIdentifierType complex type: */
class SOAP_CMAC ns6__CRLIdentifierType
{
public:
	char *ns6__Issuer;	/* required element of XSD type xsd:anyType */
	char *ns6__IssueTime;	/* required element of XSD type xsd:anyType */
	char *ns6__Number;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CRLIdentifierType (77)
	virtual int soap_type(void) const { return 77; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CRLIdentifierType, default initialized and not managed by a soap context
	virtual ns6__CRLIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLIdentifierType); }
	         ns6__CRLIdentifierType() { ns6__CRLIdentifierType::soap_default(NULL); }
	virtual ~ns6__CRLIdentifierType() { }
	friend SOAP_FMAC1 ns6__CRLIdentifierType * SOAP_FMAC2 soap_instantiate_ns6__CRLIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:396 */
#ifndef SOAP_TYPE_ns6__OCSPRefsType
#define SOAP_TYPE_ns6__OCSPRefsType (78)
/* ns6:OCSPRefsType complex type: */
class SOAP_CMAC ns6__OCSPRefsType
{
public:
	std::vector<ns6__OCSPRefType *> ns6__OCSPRef;	/* required element of XSD type ns6:OCSPRefType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__OCSPRefsType (78)
	virtual int soap_type(void) const { return 78; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__OCSPRefsType, default initialized and not managed by a soap context
	virtual ns6__OCSPRefsType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPRefsType); }
	         ns6__OCSPRefsType() { ns6__OCSPRefsType::soap_default(NULL); }
	virtual ~ns6__OCSPRefsType() { }
	friend SOAP_FMAC1 ns6__OCSPRefsType * SOAP_FMAC2 soap_instantiate_ns6__OCSPRefsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:399 */
#ifndef SOAP_TYPE_ns6__OCSPRefType
#define SOAP_TYPE_ns6__OCSPRefType (79)
/* ns6:OCSPRefType complex type: */
class SOAP_CMAC ns6__OCSPRefType
{
public:
	ns6__OCSPIdentifierType *ns6__OCSPIdentifier;	/* required element of XSD type ns6:OCSPIdentifierType */
	ns6__DigestAlgAndValueType *ns6__DigestAlgAndValue;	/* required element of XSD type ns6:DigestAlgAndValueType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__OCSPRefType (79)
	virtual int soap_type(void) const { return 79; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__OCSPRefType, default initialized and not managed by a soap context
	virtual ns6__OCSPRefType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPRefType); }
	         ns6__OCSPRefType() { ns6__OCSPRefType::soap_default(NULL); }
	virtual ~ns6__OCSPRefType() { }
	friend SOAP_FMAC1 ns6__OCSPRefType * SOAP_FMAC2 soap_instantiate_ns6__OCSPRefType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:402 */
#ifndef SOAP_TYPE_ns6__OCSPIdentifierType
#define SOAP_TYPE_ns6__OCSPIdentifierType (80)
/* ns6:OCSPIdentifierType complex type: */
class SOAP_CMAC ns6__OCSPIdentifierType
{
public:
	ns6__ResponderIDType *ns6__ResponderID;	/* required element of XSD type ns6:ResponderIDType */
	char *ns6__ProducedAt;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__OCSPIdentifierType (80)
	virtual int soap_type(void) const { return 80; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__OCSPIdentifierType, default initialized and not managed by a soap context
	virtual ns6__OCSPIdentifierType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPIdentifierType); }
	         ns6__OCSPIdentifierType() { ns6__OCSPIdentifierType::soap_default(NULL); }
	virtual ~ns6__OCSPIdentifierType() { }
	friend SOAP_FMAC1 ns6__OCSPIdentifierType * SOAP_FMAC2 soap_instantiate_ns6__OCSPIdentifierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:405 */
#ifndef SOAP_TYPE_ns6__ResponderIDType
#define SOAP_TYPE_ns6__ResponderIDType (81)
/* ns6:ResponderIDType complex type: */
class SOAP_CMAC ns6__ResponderIDType
{
public:
	char *ns6__ByName;	/* required element of XSD type xsd:anyType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__ResponderIDType (81)
	virtual int soap_type(void) const { return 81; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__ResponderIDType, default initialized and not managed by a soap context
	virtual ns6__ResponderIDType *soap_alloc(void) const { return SOAP_NEW(ns6__ResponderIDType); }
	         ns6__ResponderIDType() { ns6__ResponderIDType::soap_default(NULL); }
	virtual ~ns6__ResponderIDType() { }
	friend SOAP_FMAC1 ns6__ResponderIDType * SOAP_FMAC2 soap_instantiate_ns6__ResponderIDType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:408 */
#ifndef SOAP_TYPE_ns6__SigAndRefsTimeStampType
#define SOAP_TYPE_ns6__SigAndRefsTimeStampType (82)
/* ns6:SigAndRefsTimeStampType complex type: */
class SOAP_CMAC ns6__SigAndRefsTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns6__EncapsulatedTimeStamp;	/* required element of XSD type ns6:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__SigAndRefsTimeStampType (82)
	virtual int soap_type(void) const { return 82; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__SigAndRefsTimeStampType, default initialized and not managed by a soap context
	virtual ns6__SigAndRefsTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__SigAndRefsTimeStampType); }
	         ns6__SigAndRefsTimeStampType() { ns6__SigAndRefsTimeStampType::soap_default(NULL); }
	virtual ~ns6__SigAndRefsTimeStampType() { }
	friend SOAP_FMAC1 ns6__SigAndRefsTimeStampType * SOAP_FMAC2 soap_instantiate_ns6__SigAndRefsTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:411 */
#ifndef SOAP_TYPE_ns6__CertificateValuesType
#define SOAP_TYPE_ns6__CertificateValuesType (83)
/* ns6:CertificateValuesType complex type: */
class SOAP_CMAC ns6__CertificateValuesType
{
public:
	std::vector<ns6__EncapsulatedX509CertificateType *> ns6__EncapsulatedX509Certificate;	/* required element of XSD type ns6:EncapsulatedX509CertificateType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CertificateValuesType (83)
	virtual int soap_type(void) const { return 83; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CertificateValuesType, default initialized and not managed by a soap context
	virtual ns6__CertificateValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__CertificateValuesType); }
	         ns6__CertificateValuesType() { ns6__CertificateValuesType::soap_default(NULL); }
	virtual ~ns6__CertificateValuesType() { }
	friend SOAP_FMAC1 ns6__CertificateValuesType * SOAP_FMAC2 soap_instantiate_ns6__CertificateValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:417 */
#ifndef SOAP_TYPE_ns6__RevocationValuesType
#define SOAP_TYPE_ns6__RevocationValuesType (85)
/* ns6:RevocationValuesType complex type: */
class SOAP_CMAC ns6__RevocationValuesType
{
public:
	ns6__CRLValuesType *ns6__CRLValues;	/* required element of XSD type ns6:CRLValuesType */
	ns6__OCSPValuesType *ns6__OCSPValues;	/* required element of XSD type ns6:OCSPValuesType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__RevocationValuesType (85)
	virtual int soap_type(void) const { return 85; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__RevocationValuesType, default initialized and not managed by a soap context
	virtual ns6__RevocationValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__RevocationValuesType); }
	         ns6__RevocationValuesType() { ns6__RevocationValuesType::soap_default(NULL); }
	virtual ~ns6__RevocationValuesType() { }
	friend SOAP_FMAC1 ns6__RevocationValuesType * SOAP_FMAC2 soap_instantiate_ns6__RevocationValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:420 */
#ifndef SOAP_TYPE_ns6__CRLValuesType
#define SOAP_TYPE_ns6__CRLValuesType (86)
/* ns6:CRLValuesType complex type: */
class SOAP_CMAC ns6__CRLValuesType
{
public:
	std::vector<ns6__EncapsulatedCRLValueType *> ns6__EncapsulatedCRLValue;	/* required element of XSD type ns6:EncapsulatedCRLValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__CRLValuesType (86)
	virtual int soap_type(void) const { return 86; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__CRLValuesType, default initialized and not managed by a soap context
	virtual ns6__CRLValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__CRLValuesType); }
	         ns6__CRLValuesType() { ns6__CRLValuesType::soap_default(NULL); }
	virtual ~ns6__CRLValuesType() { }
	friend SOAP_FMAC1 ns6__CRLValuesType * SOAP_FMAC2 soap_instantiate_ns6__CRLValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:426 */
#ifndef SOAP_TYPE_ns6__OCSPValuesType
#define SOAP_TYPE_ns6__OCSPValuesType (88)
/* ns6:OCSPValuesType complex type: */
class SOAP_CMAC ns6__OCSPValuesType
{
public:
	std::vector<ns6__EncapsulatedOCSPValueType *> ns6__EncapsulatedOCSPValue;	/* required element of XSD type ns6:EncapsulatedOCSPValueType */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__OCSPValuesType (88)
	virtual int soap_type(void) const { return 88; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__OCSPValuesType, default initialized and not managed by a soap context
	virtual ns6__OCSPValuesType *soap_alloc(void) const { return SOAP_NEW(ns6__OCSPValuesType); }
	         ns6__OCSPValuesType() { ns6__OCSPValuesType::soap_default(NULL); }
	virtual ~ns6__OCSPValuesType() { }
	friend SOAP_FMAC1 ns6__OCSPValuesType * SOAP_FMAC2 soap_instantiate_ns6__OCSPValuesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:432 */
#ifndef SOAP_TYPE_ns6__ArchiveTimeStampType
#define SOAP_TYPE_ns6__ArchiveTimeStampType (90)
/* ns6:ArchiveTimeStampType complex type: */
class SOAP_CMAC ns6__ArchiveTimeStampType
{
public:
	ns5__CanonicalizationMethodType *ns5__CanonicalizationMethod;	/* required element of XSD type ns5:CanonicalizationMethodType */
	xsd__base64Binary ns6__EncapsulatedTimeStamp;	/* required element of XSD type ns6:EncapsulatedTimeStampType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__ArchiveTimeStampType (90)
	virtual int soap_type(void) const { return 90; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__ArchiveTimeStampType, default initialized and not managed by a soap context
	virtual ns6__ArchiveTimeStampType *soap_alloc(void) const { return SOAP_NEW(ns6__ArchiveTimeStampType); }
	         ns6__ArchiveTimeStampType() { ns6__ArchiveTimeStampType::soap_default(NULL); }
	virtual ~ns6__ArchiveTimeStampType() { }
	friend SOAP_FMAC1 ns6__ArchiveTimeStampType * SOAP_FMAC2 soap_instantiate_ns6__ArchiveTimeStampType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:450 */
#ifndef SOAP_TYPE_ns7__SVGListType
#define SOAP_TYPE_ns7__SVGListType (96)
/* ns7:SVGListType complex type: */
class SOAP_CMAC ns7__SVGListType
{
public:
	std::vector<xsd__base64Binary> ns7__SVG;	/* required element of XSD type ns7:SVGType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns7__SVGListType (96)
	virtual int soap_type(void) const { return 96; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns7__SVGListType, default initialized and not managed by a soap context
	virtual ns7__SVGListType *soap_alloc(void) const { return SOAP_NEW(ns7__SVGListType); }
	         ns7__SVGListType() { ns7__SVGListType::soap_default(NULL); }
	virtual ~ns7__SVGListType() { }
	friend SOAP_FMAC1 ns7__SVGListType * SOAP_FMAC2 soap_instantiate_ns7__SVGListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:453 */
#ifndef SOAP_TYPE_ns9__AttributeSupplierResponseType
#define SOAP_TYPE_ns9__AttributeSupplierResponseType (97)
/* ns9:AttributeSupplierResponseType complex type: */
class SOAP_CMAC ns9__AttributeSupplierResponseType
{
public:
	std::vector<ns3__AttributeSupplierType *> AttributeSupplier;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of XSD type ns3:AttributeSupplierType */
	std::string *ErrorMessage;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns9__AttributeSupplierResponseType (97)
	virtual int soap_type(void) const { return 97; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns9__AttributeSupplierResponseType, default initialized and not managed by a soap context
	virtual ns9__AttributeSupplierResponseType *soap_alloc(void) const { return SOAP_NEW(ns9__AttributeSupplierResponseType); }
	         ns9__AttributeSupplierResponseType() { ns9__AttributeSupplierResponseType::soap_default(NULL); }
	virtual ~ns9__AttributeSupplierResponseType() { }
	friend SOAP_FMAC1 ns9__AttributeSupplierResponseType * SOAP_FMAC2 soap_instantiate_ns9__AttributeSupplierResponseType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:456 */
#ifndef SOAP_TYPE_pdf__SignRequest
#define SOAP_TYPE_pdf__SignRequest (98)
/* pdf:SignRequest complex type: */
class SOAP_CMAC pdf__SignRequest
{
public:
	std::string ProcessId;	/* required element of XSD type xsd:string */
	pdf__PersonalDataType *PersonalData;	/* required element of XSD type pdf:PersonalDataType */
	pdf__AttributeListType *AttributeList;	/* required element of XSD type pdf:AttributeListType */
	std::string SignatureFieldName;	/* required element of XSD type xsd:string */
	xsd__base64Binary SignDocument;	/* required element of XSD type xsd:base64Binary */
	int *LTV;	/* optional element of XSD type xsd:int */
	int Page;	/* required element of XSD type xsd:int */
	int X;	/* required element of XSD type xsd:int */
	int Y;	/* required element of XSD type xsd:int */
	enum pdf__SignatureOrientationEnumType Orientation;	/* required element of XSD type pdf:SignatureOrientationEnumType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__SignRequest (98)
	virtual int soap_type(void) const { return 98; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__SignRequest, default initialized and not managed by a soap context
	virtual pdf__SignRequest *soap_alloc(void) const { return SOAP_NEW(pdf__SignRequest); }
	         pdf__SignRequest() { pdf__SignRequest::soap_default(NULL); }
	virtual ~pdf__SignRequest() { }
	friend SOAP_FMAC1 pdf__SignRequest * SOAP_FMAC2 soap_instantiate_pdf__SignRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:459 */
#ifndef SOAP_TYPE_pdf__PersonalDataType
#define SOAP_TYPE_pdf__PersonalDataType (99)
/* pdf:PersonalDataType complex type: */
class SOAP_CMAC pdf__PersonalDataType
{
public:
	std::string Name;	/* required element of XSD type xsd:string */
	std::string NIC;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__PersonalDataType (99)
	virtual int soap_type(void) const { return 99; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__PersonalDataType, default initialized and not managed by a soap context
	virtual pdf__PersonalDataType *soap_alloc(void) const { return SOAP_NEW(pdf__PersonalDataType); }
	         pdf__PersonalDataType() { pdf__PersonalDataType::soap_default(NULL); }
	virtual ~pdf__PersonalDataType() { }
	friend SOAP_FMAC1 pdf__PersonalDataType * SOAP_FMAC2 soap_instantiate_pdf__PersonalDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:462 */
#ifndef SOAP_TYPE_pdf__AttributeListType
#define SOAP_TYPE_pdf__AttributeListType (100)
/* pdf:AttributeListType complex type: */
class SOAP_CMAC pdf__AttributeListType
{
public:
	std::vector<pdf__AttributeType *> Attribute;	/* required element of XSD type pdf:AttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__AttributeListType (100)
	virtual int soap_type(void) const { return 100; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__AttributeListType, default initialized and not managed by a soap context
	virtual pdf__AttributeListType *soap_alloc(void) const { return SOAP_NEW(pdf__AttributeListType); }
	         pdf__AttributeListType() { pdf__AttributeListType::soap_default(NULL); }
	virtual ~pdf__AttributeListType() { }
	friend SOAP_FMAC1 pdf__AttributeListType * SOAP_FMAC2 soap_instantiate_pdf__AttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:465 */
#ifndef SOAP_TYPE_pdf__AttributeType
#define SOAP_TYPE_pdf__AttributeType (101)
/* pdf:AttributeType complex type: */
class SOAP_CMAC pdf__AttributeType
{
public:
	pdf__AttributeSupplierType *AttributeSupplier;	/* required element of XSD type pdf:AttributeSupplierType */
	pdf__MainAttributeType *MainAttribute;	/* required element of XSD type pdf:MainAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__AttributeType (101)
	virtual int soap_type(void) const { return 101; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__AttributeType, default initialized and not managed by a soap context
	virtual pdf__AttributeType *soap_alloc(void) const { return SOAP_NEW(pdf__AttributeType); }
	         pdf__AttributeType() { pdf__AttributeType::soap_default(NULL); }
	virtual ~pdf__AttributeType() { }
	friend SOAP_FMAC1 pdf__AttributeType * SOAP_FMAC2 soap_instantiate_pdf__AttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:468 */
#ifndef SOAP_TYPE_pdf__AttributeSupplierType
#define SOAP_TYPE_pdf__AttributeSupplierType (102)
/* pdf:AttributeSupplierType complex type: */
class SOAP_CMAC pdf__AttributeSupplierType
{
public:
	std::string Id;	/* required element of XSD type xsd:anyURI */
	std::string Name;	/* required element of XSD type xsd:string */
	std::string *Type;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__AttributeSupplierType (102)
	virtual int soap_type(void) const { return 102; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__AttributeSupplierType, default initialized and not managed by a soap context
	virtual pdf__AttributeSupplierType *soap_alloc(void) const { return SOAP_NEW(pdf__AttributeSupplierType); }
	         pdf__AttributeSupplierType() { pdf__AttributeSupplierType::soap_default(NULL); }
	virtual ~pdf__AttributeSupplierType() { }
	friend SOAP_FMAC1 pdf__AttributeSupplierType * SOAP_FMAC2 soap_instantiate_pdf__AttributeSupplierType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:471 */
#ifndef SOAP_TYPE_pdf__MainAttributeType
#define SOAP_TYPE_pdf__MainAttributeType (103)
/* pdf:MainAttributeType complex type: */
class SOAP_CMAC pdf__MainAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type xsd:string */
	pdf__LegalActListType *LegalActList;	/* optional element of XSD type pdf:LegalActListType */
	pdf__SubAttributeListType *SubAttributeList;	/* optional element of XSD type pdf:SubAttributeListType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__MainAttributeType (103)
	virtual int soap_type(void) const { return 103; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__MainAttributeType, default initialized and not managed by a soap context
	virtual pdf__MainAttributeType *soap_alloc(void) const { return SOAP_NEW(pdf__MainAttributeType); }
	         pdf__MainAttributeType() { pdf__MainAttributeType::soap_default(NULL); }
	virtual ~pdf__MainAttributeType() { }
	friend SOAP_FMAC1 pdf__MainAttributeType * SOAP_FMAC2 soap_instantiate_pdf__MainAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:474 */
#ifndef SOAP_TYPE_pdf__LegalActListType
#define SOAP_TYPE_pdf__LegalActListType (104)
/* pdf:LegalActListType complex type: */
class SOAP_CMAC pdf__LegalActListType
{
public:
	std::vector<std::string> LegalAct;	/* required element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__LegalActListType (104)
	virtual int soap_type(void) const { return 104; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__LegalActListType, default initialized and not managed by a soap context
	virtual pdf__LegalActListType *soap_alloc(void) const { return SOAP_NEW(pdf__LegalActListType); }
	         pdf__LegalActListType() { pdf__LegalActListType::soap_default(NULL); }
	virtual ~pdf__LegalActListType() { }
	friend SOAP_FMAC1 pdf__LegalActListType * SOAP_FMAC2 soap_instantiate_pdf__LegalActListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:477 */
#ifndef SOAP_TYPE_pdf__SubAttributeListType
#define SOAP_TYPE_pdf__SubAttributeListType (105)
/* pdf:SubAttributeListType complex type: */
class SOAP_CMAC pdf__SubAttributeListType
{
public:
	std::vector<pdf__SubAttributeType *> SubAttribute;	/* required element of XSD type pdf:SubAttributeType */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__SubAttributeListType (105)
	virtual int soap_type(void) const { return 105; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__SubAttributeListType, default initialized and not managed by a soap context
	virtual pdf__SubAttributeListType *soap_alloc(void) const { return SOAP_NEW(pdf__SubAttributeListType); }
	         pdf__SubAttributeListType() { pdf__SubAttributeListType::soap_default(NULL); }
	virtual ~pdf__SubAttributeListType() { }
	friend SOAP_FMAC1 pdf__SubAttributeListType * SOAP_FMAC2 soap_instantiate_pdf__SubAttributeListType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:480 */
#ifndef SOAP_TYPE_pdf__SubAttributeType
#define SOAP_TYPE_pdf__SubAttributeType (106)
/* pdf:SubAttributeType complex type: */
class SOAP_CMAC pdf__SubAttributeType
{
public:
	std::string AttributeID;	/* required element of XSD type xsd:string */
	std::string *Description;	/* optional element of XSD type xsd:string */
	std::string *Value;	/* optional element of XSD type xsd:string */
	pdf__LegalActListType *LegalActList;	/* optional element of XSD type pdf:LegalActListType */
	std::string *Type;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__SubAttributeType (106)
	virtual int soap_type(void) const { return 106; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__SubAttributeType, default initialized and not managed by a soap context
	virtual pdf__SubAttributeType *soap_alloc(void) const { return SOAP_NEW(pdf__SubAttributeType); }
	         pdf__SubAttributeType() { pdf__SubAttributeType::soap_default(NULL); }
	virtual ~pdf__SubAttributeType() { }
	friend SOAP_FMAC1 pdf__SubAttributeType * SOAP_FMAC2 soap_instantiate_pdf__SubAttributeType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:483 */
#ifndef SOAP_TYPE_pdf__SignResponse
#define SOAP_TYPE_pdf__SignResponse (107)
/* pdf:SignResponse complex type: */
class SOAP_CMAC pdf__SignResponse
{
public:
	std::string ProcessId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:string */
	pdf__Status *Status;	/* required element of XSD type pdf:Status */
	xsd__base64Binary *SignedDocument;	/* optional element of XSD type xsd:base64Binary */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__SignResponse (107)
	virtual int soap_type(void) const { return 107; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__SignResponse, default initialized and not managed by a soap context
	virtual pdf__SignResponse *soap_alloc(void) const { return SOAP_NEW(pdf__SignResponse); }
	         pdf__SignResponse() { pdf__SignResponse::soap_default(NULL); }
	virtual ~pdf__SignResponse() { }
	friend SOAP_FMAC1 pdf__SignResponse * SOAP_FMAC2 soap_instantiate_pdf__SignResponse(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:486 */
#ifndef SOAP_TYPE_pdf__Status
#define SOAP_TYPE_pdf__Status (108)
/* pdf:Status complex type: */
class SOAP_CMAC pdf__Status
{
public:
	std::string Code;	/* required element of XSD type xsd:string */
	std::string Message;	/* required element of XSD type xsd:string */
	std::string *Field;	/* optional element of XSD type xsd:string */
	std::string *FieldValue;	/* optional element of XSD type xsd:string */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_pdf__Status (108)
	virtual int soap_type(void) const { return 108; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type pdf__Status, default initialized and not managed by a soap context
	virtual pdf__Status *soap_alloc(void) const { return SOAP_NEW(pdf__Status); }
	         pdf__Status() { pdf__Status::soap_default(NULL); }
	virtual ~pdf__Status() { }
	friend SOAP_FMAC1 pdf__Status * SOAP_FMAC2 soap_instantiate_pdf__Status(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:294 */
#ifndef SOAP_TYPE_ns5__X509CertificateType
#define SOAP_TYPE_ns5__X509CertificateType (44)
/* ns5:X509CertificateType simple type: */
class SOAP_CMAC ns5__X509CertificateType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__X509CertificateType (44)
	virtual int soap_type(void) const { return 44; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__X509CertificateType, default initialized and not managed by a soap context
	virtual ns5__X509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns5__X509CertificateType); }
	         ns5__X509CertificateType() { ns5__X509CertificateType::soap_default(NULL); }
	virtual ~ns5__X509CertificateType() { }
	friend SOAP_FMAC1 ns5__X509CertificateType * SOAP_FMAC2 soap_instantiate_ns5__X509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:297 */
#ifndef SOAP_TYPE_ns5__DigestValueType
#define SOAP_TYPE_ns5__DigestValueType (45)
/* ns5:DigestValueType simple type: */
class SOAP_CMAC ns5__DigestValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string *Id;	/* optional attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__DigestValueType (45)
	virtual int soap_type(void) const { return 45; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__DigestValueType, default initialized and not managed by a soap context
	virtual ns5__DigestValueType *soap_alloc(void) const { return SOAP_NEW(ns5__DigestValueType); }
	         ns5__DigestValueType() { ns5__DigestValueType::soap_default(NULL); }
	virtual ~ns5__DigestValueType() { }
	friend SOAP_FMAC1 ns5__DigestValueType * SOAP_FMAC2 soap_instantiate_ns5__DigestValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:300 */
#ifndef SOAP_TYPE_ns5__SignatureValueType
#define SOAP_TYPE_ns5__SignatureValueType (46)
/* ns5:SignatureValueType simple type: */
class SOAP_CMAC ns5__SignatureValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns5__SignatureValueType (46)
	virtual int soap_type(void) const { return 46; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns5__SignatureValueType, default initialized and not managed by a soap context
	virtual ns5__SignatureValueType *soap_alloc(void) const { return SOAP_NEW(ns5__SignatureValueType); }
	         ns5__SignatureValueType() { ns5__SignatureValueType::soap_default(NULL); }
	virtual ~ns5__SignatureValueType() { }
	friend SOAP_FMAC1 ns5__SignatureValueType * SOAP_FMAC2 soap_instantiate_ns5__SignatureValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:414 */
#ifndef SOAP_TYPE_ns6__EncapsulatedX509CertificateType
#define SOAP_TYPE_ns6__EncapsulatedX509CertificateType (84)
/* ns6:EncapsulatedX509CertificateType simple type: */
class SOAP_CMAC ns6__EncapsulatedX509CertificateType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__EncapsulatedX509CertificateType (84)
	virtual int soap_type(void) const { return 84; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__EncapsulatedX509CertificateType, default initialized and not managed by a soap context
	virtual ns6__EncapsulatedX509CertificateType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedX509CertificateType); }
	         ns6__EncapsulatedX509CertificateType() { ns6__EncapsulatedX509CertificateType::soap_default(NULL); }
	virtual ~ns6__EncapsulatedX509CertificateType() { }
	friend SOAP_FMAC1 ns6__EncapsulatedX509CertificateType * SOAP_FMAC2 soap_instantiate_ns6__EncapsulatedX509CertificateType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:423 */
#ifndef SOAP_TYPE_ns6__EncapsulatedCRLValueType
#define SOAP_TYPE_ns6__EncapsulatedCRLValueType (87)
/* ns6:EncapsulatedCRLValueType simple type: */
class SOAP_CMAC ns6__EncapsulatedCRLValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__EncapsulatedCRLValueType (87)
	virtual int soap_type(void) const { return 87; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__EncapsulatedCRLValueType, default initialized and not managed by a soap context
	virtual ns6__EncapsulatedCRLValueType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedCRLValueType); }
	         ns6__EncapsulatedCRLValueType() { ns6__EncapsulatedCRLValueType::soap_default(NULL); }
	virtual ~ns6__EncapsulatedCRLValueType() { }
	friend SOAP_FMAC1 ns6__EncapsulatedCRLValueType * SOAP_FMAC2 soap_instantiate_ns6__EncapsulatedCRLValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:429 */
#ifndef SOAP_TYPE_ns6__EncapsulatedOCSPValueType
#define SOAP_TYPE_ns6__EncapsulatedOCSPValueType (89)
/* ns6:EncapsulatedOCSPValueType simple type: */
class SOAP_CMAC ns6__EncapsulatedOCSPValueType
{
public:
	xsd__base64Binary __item;	/* mixed XML content */
	std::string Id;	/* required attribute of XSD type xsd:ID */
	struct soap *soap;	/* transient (not serialized) */
public:
	/// Return the unique type ID value SOAP_TYPE_ns6__EncapsulatedOCSPValueType (89)
	virtual int soap_type(void) const { return 89; }
	/// Set object's data members to default values
	virtual void soap_default(struct soap*);
	/// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
	virtual void soap_serialize(struct soap*) const;
	/// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
	virtual int soap_put(struct soap*, const char *tag, const char *type) const;
	/// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
	virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
	/// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
	virtual void *soap_get(struct soap*, const char *tag, const char *type);
	/// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
	virtual void *soap_in(struct soap*, const char *tag, const char *type);
	/// Return a new object of type ns6__EncapsulatedOCSPValueType, default initialized and not managed by a soap context
	virtual ns6__EncapsulatedOCSPValueType *soap_alloc(void) const { return SOAP_NEW(ns6__EncapsulatedOCSPValueType); }
	         ns6__EncapsulatedOCSPValueType() { ns6__EncapsulatedOCSPValueType::soap_default(NULL); }
	virtual ~ns6__EncapsulatedOCSPValueType() { }
	friend SOAP_FMAC1 ns6__EncapsulatedOCSPValueType * SOAP_FMAC2 soap_instantiate_ns6__EncapsulatedOCSPValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:94 */
#ifndef SOAP_TYPE_wsa__EndpointReferenceType
#define SOAP_TYPE_wsa__EndpointReferenceType (306)
/* wsa:EndpointReferenceType complex type: */
struct wsa__EndpointReferenceType
{
public:
	char *Address;	/* required element of XSD type xsd:string */
	struct wsa__ReferencePropertiesType *ReferenceProperties;	/* optional element of XSD type wsa:ReferencePropertiesType */
	struct wsa__ReferenceParametersType *ReferenceParameters;	/* optional element of XSD type wsa:ReferenceParametersType */
	char **PortType;	/* optional element of XSD type xsd:QName */
	struct wsa__ServiceNameType *ServiceName;	/* optional element of XSD type wsa:ServiceNameType */
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_wsa__EndpointReferenceType */
	         wsa__EndpointReferenceType();
	friend SOAP_FMAC1 wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:97 */
#ifndef SOAP_TYPE_wsa__ReferencePropertiesType
#define SOAP_TYPE_wsa__ReferencePropertiesType (307)
/* wsa:ReferencePropertiesType complex type: */
struct wsa__ReferencePropertiesType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 307; } /* = unique type id SOAP_TYPE_wsa__ReferencePropertiesType */
	         wsa__ReferencePropertiesType();
	friend SOAP_FMAC1 wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:100 */
#ifndef SOAP_TYPE_wsa__ReferenceParametersType
#define SOAP_TYPE_wsa__ReferenceParametersType (308)
/* wsa:ReferenceParametersType complex type: */
struct wsa__ReferenceParametersType
{
public:
	int __size;	/* sequence of elements <-any> of XSD type xsd:anyType */
	char **__any;
public:
	int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_wsa__ReferenceParametersType */
	         wsa__ReferenceParametersType();
	friend SOAP_FMAC1 wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:103 */
#ifndef SOAP_TYPE_wsa__ServiceNameType
#define SOAP_TYPE_wsa__ServiceNameType (309)
/* wsa:ServiceNameType simple type: */
struct wsa__ServiceNameType
{
public:
	char *__item;	/* mixed XML content */
	char *PortName;	/* optional attribute of XSD type xsd:string */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 309; } /* = unique type id SOAP_TYPE_wsa__ServiceNameType */
	         wsa__ServiceNameType();
	friend SOAP_FMAC1 wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:106 */
#ifndef SOAP_TYPE_wsa__Relationship
#define SOAP_TYPE_wsa__Relationship (310)
/* wsa:Relationship simple type: */
struct wsa__Relationship
{
public:
	char *__item;	/* mixed XML content */
	char *RelationshipType;	/* optional attribute of XSD type xsd:QName */
	char *__anyAttribute;	/* optional attribute of XSD type xsd:anyType */
public:
	int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_wsa__Relationship */
	         wsa__Relationship();
	friend SOAP_FMAC1 wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsa.h:250 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (327)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	char *wsa__MessageID;	/* optional element of XSD type wsa:MessageID */
	struct wsa__Relationship *wsa__RelatesTo;	/* optional element of XSD type wsa:RelatesTo */
	struct wsa__EndpointReferenceType *wsa__From;	/* optional element of XSD type wsa:From */
	struct wsa__EndpointReferenceType *wsa__ReplyTo;	/* mustUnderstand */
	struct wsa__EndpointReferenceType *wsa__FaultTo;	/* mustUnderstand */
	char *wsa__To;	/* mustUnderstand */
	char *wsa__Action;	/* mustUnderstand */
public:
	int soap_type() const { return 327; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:266 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (332)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:267 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (334)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:268 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (336)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* wsa.h:273 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (340)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* SCAP-Services.h:3251 */
#ifndef SOAP_TYPE___ns1__Attributes
#define SOAP_TYPE___ns1__Attributes (344)
/* Operation wrapper: */
struct __ns1__Attributes
{
public:
	ns2__AttributeRequestType *ns2__AttributeRequest;	/* optional element of XSD type ns2:AttributeRequestType */
public:
	int soap_type() const { return 344; } /* = unique type id SOAP_TYPE___ns1__Attributes */
	         __ns1__Attributes();
	friend SOAP_FMAC1 __ns1__Attributes * SOAP_FMAC2 soap_instantiate___ns1__Attributes(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3332 */
#ifndef SOAP_TYPE___ns8__AttributeSuppliers
#define SOAP_TYPE___ns8__AttributeSuppliers (347)
/* Operation wrapper: */
struct __ns8__AttributeSuppliers
{
public:
	int soap_type() const { return 347; } /* = unique type id SOAP_TYPE___ns8__AttributeSuppliers */
	         __ns8__AttributeSuppliers();
	friend SOAP_FMAC1 __ns8__AttributeSuppliers * SOAP_FMAC2 soap_instantiate___ns8__AttributeSuppliers(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* SCAP-Services.h:3416 */
#ifndef SOAP_TYPE___pdf__Sign
#define SOAP_TYPE___pdf__Sign (351)
/* Operation wrapper: */
struct __pdf__Sign
{
public:
	pdf__SignRequest *pdf__SignRequest_;	/* optional element of XSD type pdf:SignRequest */
public:
	int soap_type() const { return 351; } /* = unique type id SOAP_TYPE___pdf__Sign */
	         __pdf__Sign();
	friend SOAP_FMAC1 __pdf__Sign * SOAP_FMAC2 soap_instantiate___pdf__Sign(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* SCAP-Services.h:101 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* SCAP-Services.h:101 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* SCAP-Services.h:205 */
#ifndef SOAP_TYPE_xsd__ID
#define SOAP_TYPE_xsd__ID (17)
typedef std::string xsd__ID;
#endif

/* SCAP-Services.h:208 */
#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (18)
typedef std::string xsd__anyURI;
#endif

/* SCAP-Services.h:211 */
#ifndef SOAP_TYPE_xsd__date
#define SOAP_TYPE_xsd__date (19)
typedef std::string xsd__date;
#endif

/* SCAP-Services.h:214 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (20)
typedef std::string xsd__integer;
#endif

/* SCAP-Services.h:435 */
#ifndef SOAP_TYPE__ns6__Issuer
#define SOAP_TYPE__ns6__Issuer (91)
typedef _XML _ns6__Issuer;
#endif

/* SCAP-Services.h:438 */
#ifndef SOAP_TYPE__ns6__IssueTime
#define SOAP_TYPE__ns6__IssueTime (92)
typedef _XML _ns6__IssueTime;
#endif

/* SCAP-Services.h:441 */
#ifndef SOAP_TYPE__ns6__Number
#define SOAP_TYPE__ns6__Number (93)
typedef _XML _ns6__Number;
#endif

/* SCAP-Services.h:444 */
#ifndef SOAP_TYPE__ns6__ByName
#define SOAP_TYPE__ns6__ByName (94)
typedef _XML _ns6__ByName;
#endif

/* SCAP-Services.h:447 */
#ifndef SOAP_TYPE__ns6__ProducedAt
#define SOAP_TYPE__ns6__ProducedAt (95)
typedef _XML _ns6__ProducedAt;
#endif

/* SCAP-Services.h:570 */
#ifndef SOAP_TYPE_ns5__X509IssuerNameType
#define SOAP_TYPE_ns5__X509IssuerNameType (109)
typedef std::string ns5__X509IssuerNameType;
#endif

/* SCAP-Services.h:574 */
#ifndef SOAP_TYPE_ns5__X509SerialNumberType
#define SOAP_TYPE_ns5__X509SerialNumberType (110)
typedef xsd__integer ns5__X509SerialNumberType;
#endif

/* SCAP-Services.h:595 */
#ifndef SOAP_TYPE_ns4__ProcessIDType
#define SOAP_TYPE_ns4__ProcessIDType (111)
typedef std::string ns4__ProcessIDType;
#endif

/* SCAP-Services.h:600 */
#ifndef SOAP_TYPE_ns4__NameType
#define SOAP_TYPE_ns4__NameType (112)
typedef std::string ns4__NameType;
#endif

/* SCAP-Services.h:604 */
#ifndef SOAP_TYPE_ns4__ValidityType
#define SOAP_TYPE_ns4__ValidityType (113)
typedef xsd__date ns4__ValidityType;
#endif

/* SCAP-Services.h:608 */
#ifndef SOAP_TYPE_ns4__DateType
#define SOAP_TYPE_ns4__DateType (114)
typedef xsd__date ns4__DateType;
#endif

/* SCAP-Services.h:613 */
#ifndef SOAP_TYPE_ns4__NICType
#define SOAP_TYPE_ns4__NICType (115)
typedef std::string ns4__NICType;
#endif

/* SCAP-Services.h:618 */
#ifndef SOAP_TYPE_ns4__NIPCType
#define SOAP_TYPE_ns4__NIPCType (116)
typedef std::string ns4__NIPCType;
#endif

/* SCAP-Services.h:623 */
#ifndef SOAP_TYPE_ns4__CompanyNameType
#define SOAP_TYPE_ns4__CompanyNameType (117)
typedef std::string ns4__CompanyNameType;
#endif

/* SCAP-Services.h:628 */
#ifndef SOAP_TYPE_ns4__ExtraIDValueType
#define SOAP_TYPE_ns4__ExtraIDValueType (118)
typedef std::string ns4__ExtraIDValueType;
#endif

/* SCAP-Services.h:633 */
#ifndef SOAP_TYPE_ns4__AttributeIDType
#define SOAP_TYPE_ns4__AttributeIDType (119)
typedef std::string ns4__AttributeIDType;
#endif

/* SCAP-Services.h:638 */
#ifndef SOAP_TYPE_ns4__LegalActType
#define SOAP_TYPE_ns4__LegalActType (120)
typedef std::string ns4__LegalActType;
#endif

/* SCAP-Services.h:643 */
#ifndef SOAP_TYPE_ns4__SubAttributeValueType
#define SOAP_TYPE_ns4__SubAttributeValueType (121)
typedef std::string ns4__SubAttributeValueType;
#endif

/* SCAP-Services.h:648 */
#ifndef SOAP_TYPE_ns4__DescriptionType
#define SOAP_TYPE_ns4__DescriptionType (122)
typedef std::string ns4__DescriptionType;
#endif

/* SCAP-Services.h:653 */
#ifndef SOAP_TYPE_ns4__ResponseCodeType
#define SOAP_TYPE_ns4__ResponseCodeType (123)
typedef std::string ns4__ResponseCodeType;
#endif

/* SCAP-Services.h:658 */
#ifndef SOAP_TYPE_ns4__ResponseCodeMessage
#define SOAP_TYPE_ns4__ResponseCodeMessage (124)
typedef std::string ns4__ResponseCodeMessage;
#endif

/* SCAP-Services.h:670 */
#ifndef SOAP_TYPE_ns6__SigningTimeType
#define SOAP_TYPE_ns6__SigningTimeType (126)
typedef time_t ns6__SigningTimeType;
#endif

/* SCAP-Services.h:674 */
#ifndef SOAP_TYPE_ns6__EncapsulatedTimeStampType
#define SOAP_TYPE_ns6__EncapsulatedTimeStampType (127)
typedef xsd__base64Binary ns6__EncapsulatedTimeStampType;
#endif

/* SCAP-Services.h:678 */
#ifndef SOAP_TYPE_ns6__IssuerType
#define SOAP_TYPE_ns6__IssuerType (128)
typedef std::string ns6__IssuerType;
#endif

/* SCAP-Services.h:682 */
#ifndef SOAP_TYPE_ns6__IssueTimeType
#define SOAP_TYPE_ns6__IssueTimeType (129)
typedef time_t ns6__IssueTimeType;
#endif

/* SCAP-Services.h:686 */
#ifndef SOAP_TYPE_ns6__NumberType
#define SOAP_TYPE_ns6__NumberType (130)
typedef xsd__integer ns6__NumberType;
#endif

/* SCAP-Services.h:690 */
#ifndef SOAP_TYPE_ns6__ByNameType
#define SOAP_TYPE_ns6__ByNameType (131)
typedef std::string ns6__ByNameType;
#endif

/* SCAP-Services.h:694 */
#ifndef SOAP_TYPE_ns6__ProducedAtType
#define SOAP_TYPE_ns6__ProducedAtType (132)
typedef time_t ns6__ProducedAtType;
#endif

/* SCAP-Services.h:706 */
#ifndef SOAP_TYPE_ns7__SVGType
#define SOAP_TYPE_ns7__SVGType (133)
typedef xsd__base64Binary ns7__SVGType;
#endif

/* SCAP-Services.h:2737 */
#ifndef SOAP_TYPE__ns2__AttributeRequest
#define SOAP_TYPE__ns2__AttributeRequest (243)
typedef ns2__AttributeRequestType _ns2__AttributeRequest;
#endif

/* SCAP-Services.h:2740 */
#ifndef SOAP_TYPE__ns2__AttributeResponse
#define SOAP_TYPE__ns2__AttributeResponse (244)
typedef ns2__AttributeResponseType _ns2__AttributeResponse;
#endif

/* SCAP-Services.h:2743 */
#ifndef SOAP_TYPE__ns2__PSAAttributeRequest
#define SOAP_TYPE__ns2__PSAAttributeRequest (245)
typedef ns2__PSAAttributeRequestType _ns2__PSAAttributeRequest;
#endif

/* SCAP-Services.h:2746 */
#ifndef SOAP_TYPE__ns2__SingleAttributeResponse
#define SOAP_TYPE__ns2__SingleAttributeResponse (246)
typedef ns2__SingleAttributeResponseType _ns2__SingleAttributeResponse;
#endif

/* SCAP-Services.h:2765 */
#ifndef SOAP_TYPE__ns5__Signature
#define SOAP_TYPE__ns5__Signature (247)
typedef ns5__SignatureType _ns5__Signature;
#endif

/* SCAP-Services.h:2768 */
#ifndef SOAP_TYPE__ns5__SignedInfo
#define SOAP_TYPE__ns5__SignedInfo (248)
typedef ns5__SignedInfoType _ns5__SignedInfo;
#endif

/* SCAP-Services.h:2771 */
#ifndef SOAP_TYPE__ns5__CanonicalizationMethod
#define SOAP_TYPE__ns5__CanonicalizationMethod (249)
typedef ns5__CanonicalizationMethodType _ns5__CanonicalizationMethod;
#endif

/* SCAP-Services.h:2774 */
#ifndef SOAP_TYPE__ns5__SignatureMethod
#define SOAP_TYPE__ns5__SignatureMethod (250)
typedef ns5__SignatureMethodType _ns5__SignatureMethod;
#endif

/* SCAP-Services.h:2777 */
#ifndef SOAP_TYPE__ns5__Reference
#define SOAP_TYPE__ns5__Reference (251)
typedef ns5__ReferenceType _ns5__Reference;
#endif

/* SCAP-Services.h:2780 */
#ifndef SOAP_TYPE__ns5__Transforms
#define SOAP_TYPE__ns5__Transforms (252)
typedef ns5__TransformsType _ns5__Transforms;
#endif

/* SCAP-Services.h:2783 */
#ifndef SOAP_TYPE__ns5__Transform
#define SOAP_TYPE__ns5__Transform (253)
typedef ns5__TransformType _ns5__Transform;
#endif

/* SCAP-Services.h:2786 */
#ifndef SOAP_TYPE__ns5__DigestMethod
#define SOAP_TYPE__ns5__DigestMethod (254)
typedef ns5__DigestMethodType _ns5__DigestMethod;
#endif

/* SCAP-Services.h:2789 */
#ifndef SOAP_TYPE__ns5__KeyInfo
#define SOAP_TYPE__ns5__KeyInfo (255)
typedef ns5__KeyInfoType _ns5__KeyInfo;
#endif

/* SCAP-Services.h:2792 */
#ifndef SOAP_TYPE__ns5__X509Data
#define SOAP_TYPE__ns5__X509Data (256)
typedef ns5__X509DataType _ns5__X509Data;
#endif

/* SCAP-Services.h:2795 */
#ifndef SOAP_TYPE__ns5__Object
#define SOAP_TYPE__ns5__Object (257)
typedef ns5__ObjectType _ns5__Object;
#endif

/* SCAP-Services.h:2798 */
#ifndef SOAP_TYPE__ns5__X509Certificate
#define SOAP_TYPE__ns5__X509Certificate (258)
typedef ns5__X509CertificateType _ns5__X509Certificate;
#endif

/* SCAP-Services.h:2801 */
#ifndef SOAP_TYPE__ns5__DigestValue
#define SOAP_TYPE__ns5__DigestValue (259)
typedef ns5__DigestValueType _ns5__DigestValue;
#endif

/* SCAP-Services.h:2804 */
#ifndef SOAP_TYPE__ns5__SignatureValue
#define SOAP_TYPE__ns5__SignatureValue (260)
typedef ns5__SignatureValueType _ns5__SignatureValue;
#endif

/* SCAP-Services.h:2807 */
#ifndef SOAP_TYPE__ns5__X509IssuerName
#define SOAP_TYPE__ns5__X509IssuerName (261)
typedef ns5__X509IssuerNameType _ns5__X509IssuerName;
#endif

/* SCAP-Services.h:2810 */
#ifndef SOAP_TYPE__ns5__X509SerialNumber
#define SOAP_TYPE__ns5__X509SerialNumber (262)
typedef ns5__X509SerialNumberType _ns5__X509SerialNumber;
#endif

/* SCAP-Services.h:2829 */
#ifndef SOAP_TYPE__ns3__Attribute
#define SOAP_TYPE__ns3__Attribute (263)
typedef ns3__AttributeType _ns3__Attribute;
#endif

/* SCAP-Services.h:2832 */
#ifndef SOAP_TYPE__ns3__SignatureAttribute
#define SOAP_TYPE__ns3__SignatureAttribute (264)
typedef ns5__SignatureType _ns3__SignatureAttribute;
#endif

/* SCAP-Services.h:2867 */
#ifndef SOAP_TYPE__ns6__QualifyingProperties
#define SOAP_TYPE__ns6__QualifyingProperties (265)
typedef ns6__QualifyingPropertiesType _ns6__QualifyingProperties;
#endif

/* SCAP-Services.h:2870 */
#ifndef SOAP_TYPE__ns6__SignedProperties
#define SOAP_TYPE__ns6__SignedProperties (266)
typedef ns6__SignedPropertiesType _ns6__SignedProperties;
#endif

/* SCAP-Services.h:2873 */
#ifndef SOAP_TYPE__ns6__SignedSignatureProperties
#define SOAP_TYPE__ns6__SignedSignatureProperties (267)
typedef ns6__SignedSignaturePropertiesType _ns6__SignedSignatureProperties;
#endif

/* SCAP-Services.h:2876 */
#ifndef SOAP_TYPE__ns6__SigningCertificate
#define SOAP_TYPE__ns6__SigningCertificate (268)
typedef ns6__SigningCertificateType _ns6__SigningCertificate;
#endif

/* SCAP-Services.h:2879 */
#ifndef SOAP_TYPE__ns6__Cert
#define SOAP_TYPE__ns6__Cert (269)
typedef ns6__CertType _ns6__Cert;
#endif

/* SCAP-Services.h:2882 */
#ifndef SOAP_TYPE__ns6__CertDigest
#define SOAP_TYPE__ns6__CertDigest (270)
typedef ns6__CertDigestType _ns6__CertDigest;
#endif

/* SCAP-Services.h:2885 */
#ifndef SOAP_TYPE__ns6__IssuerSerial
#define SOAP_TYPE__ns6__IssuerSerial (271)
typedef ns6__IssuerSerialType _ns6__IssuerSerial;
#endif

/* SCAP-Services.h:2888 */
#ifndef SOAP_TYPE__ns6__SigningTime
#define SOAP_TYPE__ns6__SigningTime (272)
typedef ns6__SigningTimeType _ns6__SigningTime;
#endif

/* SCAP-Services.h:2891 */
#ifndef SOAP_TYPE__ns6__SignerRole
#define SOAP_TYPE__ns6__SignerRole (273)
typedef ns6__SignerRoleType _ns6__SignerRole;
#endif

/* SCAP-Services.h:2894 */
#ifndef SOAP_TYPE__ns6__ClaimedRoles
#define SOAP_TYPE__ns6__ClaimedRoles (274)
typedef ns6__ClaimedRolesListType _ns6__ClaimedRoles;
#endif

/* SCAP-Services.h:2897 */
#ifndef SOAP_TYPE__ns6__ClaimedRole
#define SOAP_TYPE__ns6__ClaimedRole (275)
typedef ns6__ClaimedRoleType _ns6__ClaimedRole;
#endif

/* SCAP-Services.h:2900 */
#ifndef SOAP_TYPE__ns6__UnsignedProperties
#define SOAP_TYPE__ns6__UnsignedProperties (276)
typedef ns6__UnsignedPropertiesType _ns6__UnsignedProperties;
#endif

/* SCAP-Services.h:2903 */
#ifndef SOAP_TYPE__ns6__UnsignedSignatureProperties
#define SOAP_TYPE__ns6__UnsignedSignatureProperties (277)
typedef ns6__UnsignedSignaturePropertiesType _ns6__UnsignedSignatureProperties;
#endif

/* SCAP-Services.h:2906 */
#ifndef SOAP_TYPE__ns6__CounterSignature
#define SOAP_TYPE__ns6__CounterSignature (278)
typedef ns6__CounterSignatureType _ns6__CounterSignature;
#endif

/* SCAP-Services.h:2909 */
#ifndef SOAP_TYPE__ns6__SignatureTimeStamp
#define SOAP_TYPE__ns6__SignatureTimeStamp (279)
typedef ns6__SignatureTimeStampType _ns6__SignatureTimeStamp;
#endif

/* SCAP-Services.h:2912 */
#ifndef SOAP_TYPE__ns6__EncapsulatedTimeStamp
#define SOAP_TYPE__ns6__EncapsulatedTimeStamp (280)
typedef ns6__EncapsulatedTimeStampType _ns6__EncapsulatedTimeStamp;
#endif

/* SCAP-Services.h:2915 */
#ifndef SOAP_TYPE__ns6__CompleteCertificateRefs
#define SOAP_TYPE__ns6__CompleteCertificateRefs (281)
typedef ns6__CompleteCertificateRefsType _ns6__CompleteCertificateRefs;
#endif

/* SCAP-Services.h:2918 */
#ifndef SOAP_TYPE__ns6__CertRefs
#define SOAP_TYPE__ns6__CertRefs (282)
typedef ns6__CertRefsType _ns6__CertRefs;
#endif

/* SCAP-Services.h:2921 */
#ifndef SOAP_TYPE__ns6__CompleteRevocationRefs
#define SOAP_TYPE__ns6__CompleteRevocationRefs (283)
typedef ns6__CompleteRevocationRefsType _ns6__CompleteRevocationRefs;
#endif

/* SCAP-Services.h:2924 */
#ifndef SOAP_TYPE__ns6__CRLRefs
#define SOAP_TYPE__ns6__CRLRefs (284)
typedef ns6__CRLRefsType _ns6__CRLRefs;
#endif

/* SCAP-Services.h:2927 */
#ifndef SOAP_TYPE__ns6__CRLRef
#define SOAP_TYPE__ns6__CRLRef (285)
typedef ns6__CRLRefType _ns6__CRLRef;
#endif

/* SCAP-Services.h:2930 */
#ifndef SOAP_TYPE__ns6__DigestAlgAndValue
#define SOAP_TYPE__ns6__DigestAlgAndValue (286)
typedef ns6__DigestAlgAndValueType _ns6__DigestAlgAndValue;
#endif

/* SCAP-Services.h:2933 */
#ifndef SOAP_TYPE__ns6__CRLIdentifier
#define SOAP_TYPE__ns6__CRLIdentifier (287)
typedef ns6__CRLIdentifierType _ns6__CRLIdentifier;
#endif

/* SCAP-Services.h:2936 */
#ifndef SOAP_TYPE__ns6__OCSPRefs
#define SOAP_TYPE__ns6__OCSPRefs (288)
typedef ns6__OCSPRefsType _ns6__OCSPRefs;
#endif

/* SCAP-Services.h:2939 */
#ifndef SOAP_TYPE__ns6__OCSPRef
#define SOAP_TYPE__ns6__OCSPRef (289)
typedef ns6__OCSPRefType _ns6__OCSPRef;
#endif

/* SCAP-Services.h:2942 */
#ifndef SOAP_TYPE__ns6__OCSPIdentifier
#define SOAP_TYPE__ns6__OCSPIdentifier (290)
typedef ns6__OCSPIdentifierType _ns6__OCSPIdentifier;
#endif

/* SCAP-Services.h:2945 */
#ifndef SOAP_TYPE__ns6__ResponderID
#define SOAP_TYPE__ns6__ResponderID (291)
typedef ns6__ResponderIDType _ns6__ResponderID;
#endif

/* SCAP-Services.h:2948 */
#ifndef SOAP_TYPE__ns6__SigAndRefsTimeStamp
#define SOAP_TYPE__ns6__SigAndRefsTimeStamp (292)
typedef ns6__SigAndRefsTimeStampType _ns6__SigAndRefsTimeStamp;
#endif

/* SCAP-Services.h:2951 */
#ifndef SOAP_TYPE__ns6__CertificateValues
#define SOAP_TYPE__ns6__CertificateValues (293)
typedef ns6__CertificateValuesType _ns6__CertificateValues;
#endif

/* SCAP-Services.h:2954 */
#ifndef SOAP_TYPE__ns6__EncapsulatedX509Certificate
#define SOAP_TYPE__ns6__EncapsulatedX509Certificate (294)
typedef ns6__EncapsulatedX509CertificateType _ns6__EncapsulatedX509Certificate;
#endif

/* SCAP-Services.h:2957 */
#ifndef SOAP_TYPE__ns6__RevocationValues
#define SOAP_TYPE__ns6__RevocationValues (295)
typedef ns6__RevocationValuesType _ns6__RevocationValues;
#endif

/* SCAP-Services.h:2960 */
#ifndef SOAP_TYPE__ns6__CRLValues
#define SOAP_TYPE__ns6__CRLValues (296)
typedef ns6__CRLValuesType _ns6__CRLValues;
#endif

/* SCAP-Services.h:2963 */
#ifndef SOAP_TYPE__ns6__EncapsulatedCRLValue
#define SOAP_TYPE__ns6__EncapsulatedCRLValue (297)
typedef ns6__EncapsulatedCRLValueType _ns6__EncapsulatedCRLValue;
#endif

/* SCAP-Services.h:2966 */
#ifndef SOAP_TYPE__ns6__OCSPValues
#define SOAP_TYPE__ns6__OCSPValues (298)
typedef ns6__OCSPValuesType _ns6__OCSPValues;
#endif

/* SCAP-Services.h:2969 */
#ifndef SOAP_TYPE__ns6__EncapsulatedOCSPValue
#define SOAP_TYPE__ns6__EncapsulatedOCSPValue (299)
typedef ns6__EncapsulatedOCSPValueType _ns6__EncapsulatedOCSPValue;
#endif

/* SCAP-Services.h:2972 */
#ifndef SOAP_TYPE__ns6__ArchiveTimeStamp
#define SOAP_TYPE__ns6__ArchiveTimeStamp (300)
typedef ns6__ArchiveTimeStampType _ns6__ArchiveTimeStamp;
#endif

/* SCAP-Services.h:2991 */
#ifndef SOAP_TYPE__ns7__SVGList
#define SOAP_TYPE__ns7__SVGList (301)
typedef ns7__SVGListType _ns7__SVGList;
#endif

/* SCAP-Services.h:2994 */
#ifndef SOAP_TYPE__ns7__SVG
#define SOAP_TYPE__ns7__SVG (302)
typedef ns7__SVGType _ns7__SVG;
#endif

/* SCAP-Services.h:3029 */
#ifndef SOAP_TYPE__ns9__AttributeSupplierResponse
#define SOAP_TYPE__ns9__AttributeSupplierResponse (303)
typedef ns9__AttributeSupplierResponseType _ns9__AttributeSupplierResponse;
#endif

/* SCAP-Services.h:3048 */
#ifndef SOAP_TYPE__pdf__SignRequest
#define SOAP_TYPE__pdf__SignRequest (304)
typedef pdf__SignRequest _pdf__SignRequest;
#endif

/* SCAP-Services.h:3051 */
#ifndef SOAP_TYPE__pdf__SignResponse
#define SOAP_TYPE__pdf__SignResponse (305)
typedef pdf__SignResponse _pdf__SignResponse;
#endif

/* wsa.h:220 */
#ifndef SOAP_TYPE__wsa__EndpointReference
#define SOAP_TYPE__wsa__EndpointReference (318)
typedef struct wsa__EndpointReferenceType _wsa__EndpointReference;
#endif

/* wsa.h:223 */
#ifndef SOAP_TYPE__wsa__MessageID
#define SOAP_TYPE__wsa__MessageID (319)
typedef char *_wsa__MessageID;
#endif

/* wsa.h:226 */
#ifndef SOAP_TYPE__wsa__RelatesTo
#define SOAP_TYPE__wsa__RelatesTo (320)
typedef struct wsa__Relationship _wsa__RelatesTo;
#endif

/* wsa.h:229 */
#ifndef SOAP_TYPE__wsa__To
#define SOAP_TYPE__wsa__To (321)
typedef char *_wsa__To;
#endif

/* wsa.h:232 */
#ifndef SOAP_TYPE__wsa__Action
#define SOAP_TYPE__wsa__Action (322)
typedef char *_wsa__Action;
#endif

/* wsa.h:235 */
#ifndef SOAP_TYPE__wsa__From
#define SOAP_TYPE__wsa__From (323)
typedef struct wsa__EndpointReferenceType _wsa__From;
#endif

/* wsa.h:238 */
#ifndef SOAP_TYPE__wsa__ReplyTo
#define SOAP_TYPE__wsa__ReplyTo (324)
typedef struct wsa__EndpointReferenceType _wsa__ReplyTo;
#endif

/* wsa.h:241 */
#ifndef SOAP_TYPE__wsa__FaultTo
#define SOAP_TYPE__wsa__FaultTo (325)
typedef struct wsa__EndpointReferenceType _wsa__FaultTo;
#endif

/* wsa.h:244 */
#ifndef SOAP_TYPE__wsa__ReplyAfter
#define SOAP_TYPE__wsa__ReplyAfter (326)
typedef unsigned int _wsa__ReplyAfter;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of SCAPStub.h */
